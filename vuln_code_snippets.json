{"func": "int _gnutls_ciphertext2compressed(gnutls_session_t session,\n\t\t\t\t  opaque * compress_data,\n\t\t\t\t  int compress_size,\n\t\t\t\t  gnutls_datum_t ciphertext, uint8 type)\n{\n    uint8 MAC[MAX_HASH_SIZE];\n    uint16 c_length;\n    uint8 pad;\n    int length;\n    mac_hd_t td;\n    uint16 blocksize;\n    int ret, i, pad_failed = 0;\n    uint8 major, minor;\n    gnutls_protocol_t ver;\n    int hash_size =\n\t_gnutls_hash_get_algo_len(session->security_parameters.\n\t\t\t\t  read_mac_algorithm);\n\n    ver = gnutls_protocol_get_version(session);\n    minor = _gnutls_version_get_minor(ver);\n    major = _gnutls_version_get_major(ver);\n\n    blocksize = _gnutls_cipher_get_block_size(session->security_parameters.\n\t\t\t\t\t      read_bulk_cipher_algorithm);\n\n    /* initialize MAC \n     */\n    td = mac_init(session->security_parameters.read_mac_algorithm,\n\t\t  session->connection_state.read_mac_secret.data,\n\t\t  session->connection_state.read_mac_secret.size, ver);\n\n    if (td == GNUTLS_MAC_FAILED\n\t&& session->security_parameters.read_mac_algorithm !=\n\tGNUTLS_MAC_NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n    /* actual decryption (inplace)\n     */\n    switch (_gnutls_cipher_is_block\n\t    (session->security_parameters.read_bulk_cipher_algorithm)) {\n    case CIPHER_STREAM:\n\tif ((ret = _gnutls_cipher_decrypt(session->connection_state.\n\t\t\t\t\t  read_cipher_state,\n\t\t\t\t\t  ciphertext.data,\n\t\t\t\t\t  ciphertext.size)) < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n\n\tlength = ciphertext.size - hash_size;\n\n\tbreak;\n    case CIPHER_BLOCK:\n\tif ((ciphertext.size < blocksize)\n\t    || (ciphertext.size % blocksize != 0)) {\n\t    gnutls_assert();\n\t    return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n\tif ((ret = _gnutls_cipher_decrypt(session->connection_state.\n\t\t\t\t\t  read_cipher_state,\n\t\t\t\t\t  ciphertext.data,\n\t\t\t\t\t  ciphertext.size)) < 0) {\n\t    gnutls_assert();\n\t    return ret;\n\t}\n\n\t/* ignore the IV in TLS 1.1.\n\t */\n\tif (session->security_parameters.version >= GNUTLS_TLS1_1) {\n\t    ciphertext.size -= blocksize;\n\t    ciphertext.data += blocksize;\n\n\t    if (ciphertext.size == 0) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n\tpad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n\tlength = ciphertext.size - hash_size - pad;\n\n\tif (pad > ciphertext.size - hash_size) {\n\t    gnutls_assert();\n\t    /* We do not fail here. We check below for the\n\t     * the pad_failed. If zero means success.\n\t     */\n\t    pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n\t/* Check the pading bytes (TLS 1.x)\n\t */\n\tif (ver >= GNUTLS_TLS1)\n\t    for (i = 2; i < pad; i++) {\n\t\tif (ciphertext.data[ciphertext.size - i] !=\n\t\t    ciphertext.data[ciphertext.size - 1])\n\t\t    pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\n\tbreak;\n    default:\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n\n    if (length < 0)\n\tlength = 0;\n    c_length = _gnutls_conv_uint16((uint16) length);\n\n    /* Pass the type, version, length and compressed through\n     * MAC.\n     */\n    if (td != GNUTLS_MAC_FAILED) {\n\t_gnutls_hmac(td,\n\t\t     UINT64DATA(session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n\t_gnutls_hmac(td, &type, 1);\n\tif (ver >= GNUTLS_TLS1) {\t/* TLS 1.x */\n\t    _gnutls_hmac(td, &major, 1);\n\t    _gnutls_hmac(td, &minor, 1);\n\t}\n\t_gnutls_hmac(td, &c_length, 2);\n\n\tif (length > 0)\n\t    _gnutls_hmac(td, ciphertext.data, length);\n\n\tmac_deinit(td, MAC, ver);\n    }\n\n    /* This one was introduced to avoid a timing attack against the TLS\n     * 1.0 protocol.\n     */\n    if (pad_failed != 0)\n\treturn pad_failed;\n\n    /* HMAC was not the same. \n     */\n    if (memcmp(MAC, &ciphertext.data[length], hash_size) != 0) {\n\tgnutls_assert();\n\treturn GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n    /* copy the decrypted stuff to compress_data.\n     */\n    if (compress_size < length) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INTERNAL_ERROR;\n    }\n    memcpy(compress_data, ciphertext.data, length);\n\n    return length;\n}", "target": 1, "cwe": [], "project": "gnutls", "commit_id": "7ad6162573ba79a4392c63b453ad0220ca6c5ace", "hash": 73008646937836648589283922871188272089, "size": 157, "message": "added an extra check while checking the padding."}
{"func": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}", "target": 1, "cwe": ["CWE-264"], "project": "php-src", "commit_id": "055ecbc62878e86287d742c7246c21606cee8183", "hash": 211824207069112513181516095447837228041, "size": 22, "message": "Improve check for :memory: pseudo-filename in SQlite"}
{"func": "unpack_Z_stream(int fd_in, int fd_out)\n{\n\tIF_DESKTOP(long long total_written = 0;)\n\tIF_DESKTOP(long long) int retval = -1;\n\tunsigned char *stackp;\n\tlong code;\n\tint finchar;\n\tlong oldcode;\n\tlong incode;\n\tint inbits;\n\tint posbits;\n\tint outpos;\n\tint insize;\n\tint bitmask;\n\tlong free_ent;\n\tlong maxcode;\n\tlong maxmaxcode;\n\tint n_bits;\n\tint rsize = 0;\n\tunsigned char *inbuf; /* were eating insane amounts of stack - */\n\tunsigned char *outbuf; /* bad for some embedded targets */\n\tunsigned char *htab;\n\tunsigned short *codetab;\n\n\t/* Hmm, these were statics - why?! */\n\t/* user settable max # bits/code */\n\tint maxbits; /* = BITS; */\n\t/* block compress mode -C compatible with 2.0 */\n\tint block_mode; /* = BLOCK_MODE; */\n\n\tinbuf = xzalloc(IBUFSIZ + 64);\n\toutbuf = xzalloc(OBUFSIZ + 2048);\n\thtab = xzalloc(HSIZE);  /* wsn't zeroed out before, maybe can xmalloc? */\n\tcodetab = xzalloc(HSIZE * sizeof(codetab[0]));\n\n\tinsize = 0;\n\n\t/* xread isn't good here, we have to return - caller may want\n\t * to do some cleanup (e.g. delete incomplete unpacked file etc) */\n\tif (full_read(fd_in, inbuf, 1) != 1) {\n\t\tbb_error_msg(\"short read\");\n\t\tgoto err;\n\t}\n\n\tmaxbits = inbuf[0] & BIT_MASK;\n\tblock_mode = inbuf[0] & BLOCK_MODE;\n\tmaxmaxcode = MAXCODE(maxbits);\n\n\tif (maxbits > BITS) {\n\t\tbb_error_msg(\"compressed with %d bits, can only handle \"\n\t\t\t\tBITS_STR\" bits\", maxbits);\n\t\tgoto err;\n\t}\n\n\tn_bits = INIT_BITS;\n\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\tbitmask = (1 << INIT_BITS) - 1;\n\toldcode = -1;\n\tfinchar = 0;\n\toutpos = 0;\n\tposbits = 0 << 3;\n\n\tfree_ent = ((block_mode) ? FIRST : 256);\n\n\t/* As above, initialize the first 256 entries in the table. */\n\t/*clear_tab_prefixof(); - done by xzalloc */\n\n\tfor (code = 255; code >= 0; --code) {\n\t\ttab_suffixof(code) = (unsigned char) code;\n\t}\n\n\tdo {\n resetbuf:\n\t\t{\n\t\t\tint i;\n\t\t\tint e;\n\t\t\tint o;\n\n\t\t\to = posbits >> 3;\n\t\t\te = insize - o;\n\n\t\t\tfor (i = 0; i < e; ++i)\n\t\t\t\tinbuf[i] = inbuf[i + o];\n\n\t\t\tinsize = e;\n\t\t\tposbits = 0;\n\t\t}\n\n\t\tif (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {\n\t\t\trsize = safe_read(fd_in, inbuf + insize, IBUFSIZ);\n//error check??\n\t\t\tinsize += rsize;\n\t\t}\n\n\t\tinbits = ((rsize > 0) ? (insize - insize % n_bits) << 3 :\n\t\t\t\t  (insize << 3) - (n_bits - 1));\n\n\t\twhile (inbits > posbits) {\n\t\t\tif (free_ent > maxcode) {\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\t++n_bits;\n\t\t\t\tif (n_bits == maxbits) {\n\t\t\t\t\tmaxcode = maxmaxcode;\n\t\t\t\t} else {\n\t\t\t\t\tmaxcode = MAXCODE(n_bits) - 1;\n\t\t\t\t}\n\t\t\t\tbitmask = (1 << n_bits) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\t\t\t{\n\t\t\t\tunsigned char *p = &inbuf[posbits >> 3];\n\n\t\t\t\tcode = ((((long) (p[0])) | ((long) (p[1]) << 8) |\n\t\t\t\t         ((long) (p[2]) << 16)) >> (posbits & 0x7)) & bitmask;\n\t\t\t}\n\t\t\tposbits += n_bits;\n\n\n\t\t\tif (oldcode == -1) {\n\t\t\t\toldcode = code;\n\t\t\t\tfinchar = (int) oldcode;\n\t\t\t\toutbuf[outpos++] = (unsigned char) finchar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (code == CLEAR && block_mode) {\n\t\t\t\tclear_tab_prefixof();\n\t\t\t\tfree_ent = FIRST - 1;\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\tn_bits = INIT_BITS;\n\t\t\t\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\t\t\t\tbitmask = (1 << INIT_BITS) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\n\t\t\tincode = code;\n\t\t\tstackp = de_stack;\n\n\t\t\t/* Special case for KwKwK string. */\n\t\t\tif (code >= free_ent) {\n\t\t\t\tif (code > free_ent) {\n\t\t\t\t\tunsigned char *p;\n\n\t\t\t\t\tposbits -= n_bits;\n\t\t\t\t\tp = &inbuf[posbits >> 3];\n\n\t\t\t\t\tbb_error_msg\n\t\t\t\t\t\t(\"insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)\",\n\t\t\t\t\t\t insize, posbits, p[-1], p[0], p[1], p[2], p[3],\n\t\t\t\t\t\t (posbits & 07));\n\t\t\t\t\tbb_error_msg(\"corrupted data\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t*--stackp = (unsigned char) finchar;\n\t\t\t\tcode = oldcode;\n\t\t\t}\n\n\t\t\t/* Generate output characters in reverse order */\n\t\t\twhile ((long) code >= (long) 256) {\n\t\t\t\t*--stackp = tab_suffixof(code);\n\t\t\t\tcode = tab_prefixof(code);\n\t\t\t}\n\n\t\t\tfinchar = tab_suffixof(code);\n\t\t\t*--stackp = (unsigned char) finchar;\n\n\t\t\t/* And put them out in forward order */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\ti = de_stack - stackp;\n\t\t\t\tif (outpos + i >= OBUFSIZ) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (i > OBUFSIZ - outpos) {\n\t\t\t\t\t\t\ti = OBUFSIZ - outpos;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\t\t\toutpos += i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (outpos >= OBUFSIZ) {\n\t\t\t\t\t\t\tfull_write(fd_out, outbuf, outpos);\n//error check??\n\t\t\t\t\t\t\tIF_DESKTOP(total_written += outpos;)\n\t\t\t\t\t\t\toutpos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstackp += i;\n\t\t\t\t\t\ti = de_stack - stackp;\n\t\t\t\t\t} while (i > 0);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\toutpos += i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Generate the new entry. */\n\t\t\tcode = free_ent;\n\t\t\tif (code < maxmaxcode) {\n\t\t\t\ttab_prefixof(code) = (unsigned short) oldcode;\n\t\t\t\ttab_suffixof(code) = (unsigned char) finchar;\n\t\t\t\tfree_ent = code + 1;\n\t\t\t}\n\n\t\t\t/* Remember previous code.  */\n\t\t\toldcode = incode;\n\t\t}\n\n\t} while (rsize > 0);\n\n\tif (outpos > 0) {\n\t\tfull_write(fd_out, outbuf, outpos);\n//error check??\n\t\tIF_DESKTOP(total_written += outpos;)\n\t}\n\n\tretval = IF_DESKTOP(total_written) + 0;\n err:\n\tfree(inbuf);\n\tfree(outbuf);\n\tfree(htab);\n\tfree(codetab);\n\treturn retval;\n}", "target": 1, "cwe": [], "project": "busybox", "commit_id": "251fc70e9722f931eec23a34030d05ba5f747b0e", "hash": 21401706257394042943815500829552774160, "size": 232, "message": "uncompress: fix buffer underrun by corrupted input\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>"}
{"func": "static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n{\n    int sx, sy;\n    int dx, dy;\n    int width, height;\n    int depth;\n    int notify = 0;\n\n    depth = s->get_bpp((VGAState *)s) / 8;\n    s->get_resolution((VGAState *)s, &width, &height);\n\n    /* extra x, y */\n    sx = (src % (width * depth)) / depth;\n    sy = (src / (width * depth));\n    dx = (dst % (width *depth)) / depth;\n    dy = (dst / (width * depth));\n\n    /* normalize width */\n    w /= depth;\n\n    /* if we're doing a backward copy, we have to adjust\n       our x/y to be the upper left corner (instead of the lower\n       right corner) */\n    if (s->cirrus_blt_dstpitch < 0) {\n\tsx -= (s->cirrus_blt_width / depth) - 1;\n\tdx -= (s->cirrus_blt_width / depth) - 1;\n\tsy -= s->cirrus_blt_height - 1;\n\tdy -= s->cirrus_blt_height - 1;\n    }\n\n    /* are we in the visible portion of memory? */\n    if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\t(sx + w) <= width && (sy + h) <= height &&\n\t(dx + w) <= width && (dy + h) <= height) {\n\tnotify = 1;\n    }\n\n    /* make to sure only copy if it's a plain copy ROP */\n    if (*s->cirrus_rop != cirrus_bitblt_rop_fwd_src &&\n\t*s->cirrus_rop != cirrus_bitblt_rop_bkwd_src)\n\tnotify = 0;\n\n    /* we have to flush all pending changes so that the copy\n       is generated at the appropriate moment in time */\n    if (notify)\n\tvga_hw_update();\n\n    (*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t      s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    if (notify)\n\ts->ds->dpy_copy(s->ds,\n\t\t\tsx, sy, dx, dy,\n\t\t\ts->cirrus_blt_width / depth,\n\t\t\ts->cirrus_blt_height);\n\n    /* we don't have to notify the display that this portion has\n       changed since dpy_copy implies this */\n\n    if (!notify)\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 135590882627853658533498335902319684573, "size": 66, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,\n                             uint8_t *dst,const uint8_t *src,\n                             int dstpitch,int srcpitch,\n                             int bltwidth,int bltheight)\n{\n    int x,y;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x++) {\n            ROP_OP(*dst, *src);\n            dst++;\n            src++;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 27696392987383562433164405181263025184, "size": 18, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\t(*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t\t  s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 331046290845234389374470092408344022350, "size": 19, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,\n\t\t\t\t\t     unsigned mode,\n\t\t\t\t\t     unsigned offset,\n\t\t\t\t\t     uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t}\n\tval <<= 1;\n\tdst++;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 50418188797463436407734640880675508745, "size": 22, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\t\t\t\t\t    const uint8_t * src)\n{\n    uint8_t *dst;\n\n    dst = s->vram_ptr + s->cirrus_blt_dstaddr;\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 176630228639235556421341667256894067184, "size": 14, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 335738960224286063332470333845363880021, "size": 19, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vram_ptr +\n                                            (s->cirrus_blt_srcaddr & ~7));\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 58384268221957848687614989550830035306, "size": 6, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n{\n    cirrus_fill_t rop_func;\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n    rop_func(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n             s->cirrus_blt_dstpitch,\n             s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t     s->cirrus_blt_height);\n    cirrus_bitblt_reset(s);\n    return 1;\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 149842811940934737817714037905575936616, "size": 14, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static void cirrus_bitblt_cputovideo_next(CirrusVGAState * s)\n{\n    int copy_count;\n    uint8_t *end_ptr;\n\n    if (s->cirrus_srccounter > 0) {\n        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n            cirrus_bitblt_common_patterncopy(s, s->cirrus_bltbuf);\n        the_end:\n            s->cirrus_srccounter = 0;\n            cirrus_bitblt_reset(s);\n        } else {\n            /* at least one scan line */\n            do {\n                (*s->cirrus_rop)(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n                                 s->cirrus_bltbuf, 0, 0, s->cirrus_blt_width, 1);\n                cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,\n                                         s->cirrus_blt_width, 1);\n                s->cirrus_blt_dstaddr += s->cirrus_blt_dstpitch;\n                s->cirrus_srccounter -= s->cirrus_blt_srcpitch;\n                if (s->cirrus_srccounter <= 0)\n                    goto the_end;\n                /* more bytes than needed can be transfered because of\n                   word alignment, so we keep them for the next line */\n                /* XXX: keep alignment to speed up transfer */\n                end_ptr = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n                copy_count = s->cirrus_srcptr_end - end_ptr;\n                memmove(s->cirrus_bltbuf, end_ptr, copy_count);\n                s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;\n                s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n            } while (s->cirrus_srcptr >= s->cirrus_srcptr_end);\n        }\n    }\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 246597330759913647803692062244246778621, "size": 34, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s,\n\t\t\t\t\t      unsigned mode,\n\t\t\t\t\t      unsigned offset,\n\t\t\t\t\t      uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t    *(dst + 1) = s->gr[0x11];\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t    *(dst + 1) = s->gr[0x10];\n\t}\n\tval <<= 1;\n\tdst += 2;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 15);\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "b2eb849d4b1fdb6f35d5c46958c7f703cf64cfef", "hash": 241662835431977252361369897799666577695, "size": 24, "message": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\n    if (BLTUNSAFE(s))\n        return 0;\n\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}", "target": 1, "cwe": ["CWE-787"], "project": "qemu", "commit_id": "65d35a09979e63541afc5bfc595b9f1b1b4ae069", "hash": 128516004862549772575527502984330639841, "size": 25, "message": "CVE-2008-4539: fix a heap overflow in Cirrus emulation\n\nThe code in hw/cirrus_vga.c has changed a lot between CVE-2007-1320 has\nbeen announced and the patch has been applied. As a consequence it has\nwrongly applied and QEMU is still vulnerable to this bug if using VNC.\n\n(noticed by Jan Niehusmann)\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@5587 c046a42c-6fe2-441c-8c8c-71466251a162"}
{"func": "asmlinkage long compat_sys_mount(char __user * dev_name, char __user * dir_name,\n\t\t\t\t char __user * type, unsigned long flags,\n\t\t\t\t void __user * data)\n{\n\tunsigned long type_page;\n\tunsigned long data_page;\n\tunsigned long dev_page;\n\tchar *dir_page;\n\tint retval;\n\n\tretval = copy_mount_options (type, &type_page);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tdir_page = getname(dir_name);\n\tretval = PTR_ERR(dir_page);\n\tif (IS_ERR(dir_page))\n\t\tgoto out1;\n\n\tretval = copy_mount_options (dev_name, &dev_page);\n\tif (retval < 0)\n\t\tgoto out2;\n\n\tretval = copy_mount_options (data, &data_page);\n\tif (retval < 0)\n\t\tgoto out3;\n\n\tretval = -EINVAL;\n\n\tif (type_page) {\n\t\tif (!strcmp((char *)type_page, SMBFS_NAME)) {\n\t\t\tdo_smb_super_data_conv((void *)data_page);\n\t\t} else if (!strcmp((char *)type_page, NCPFS_NAME)) {\n\t\t\tdo_ncp_super_data_conv((void *)data_page);\n\t\t} else if (!strcmp((char *)type_page, NFS4_NAME)) {\n\t\t\tif (do_nfs4_super_data_conv((void *) data_page))\n\t\t\t\tgoto out4;\n\t\t}\n\t}\n\n\tlock_kernel();\n\tretval = do_mount((char*)dev_page, dir_page, (char*)type_page,\n\t\t\tflags, (void*)data_page);\n\tunlock_kernel();\n\n out4:\n\tfree_page(data_page);\n out3:\n\tfree_page(dev_page);\n out2:\n\tputname(dir_page);\n out1:\n\tfree_page(type_page);\n out:\n\treturn retval;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "822191a2fa1584a29c3224ab328507adcaeac1ab", "hash": 269348981982883739425210455454652432542, "size": 56, "message": "[PATCH] skip data conversion in compat_sys_mount when data_page is NULL\n\nOpenVZ Linux kernel team has found a problem with mounting in compat mode.\n\nSimple command \"mount -t smbfs ...\" on Fedora Core 5 distro in 32-bit mode\nleads to oops:\n\n  Unable to handle kernel NULL pointer dereference at 0000000000000000 RIP: compat_sys_mount+0xd6/0x290\n  Process mount (pid: 14656, veid=300, threadinfo ffff810034d30000, task ffff810034c86bc0)\n  Call Trace: ia32_sysret+0x0/0xa\n\nThe problem is that data_page pointer can be NULL, so we should skip data\nconversion in this case.\n\nSigned-off-by: Andrey Mirkin <amirkin@openvz.org>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "unsigned short atalk_checksum(struct ddpehdr *ddp, int len)\n{\n\tunsigned long sum = 0;\t/* Assume unsigned long is >16 bits */\n\tunsigned char *data = (unsigned char *)ddp;\n\n\tlen  -= 4;\t\t/* skip header 4 bytes */\n\tdata += 4;\n\n\t/* This ought to be unwrapped neatly. I'll trust gcc for now */\n\twhile (len--) {\n\t\tsum += *data;\n\t\tsum <<= 1;\n\t\tif (sum & 0x10000) {\n\t\t\tsum++;\n\t\t\tsum &= 0xFFFF;\n\t\t}\n\t\tdata++;\n\t}\n\t/* Use 0xFFFF for 0. 0 itself means none */\n\treturn sum ? htons((unsigned short)sum) : 0xFFFF;\n}", "target": 1, "cwe": [], "project": "history", "commit_id": "7ab442d7e0a76402c12553ee256f756097cae2d2", "hash": 21680921567039844396111342843486104161, "size": 21, "message": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets."}
{"func": "static int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct packet_type *pt)\n{\n\t/* Expand any short form frames */\n\tif (skb->mac.raw[2] == 1) {\n\t\tstruct ddpehdr *ddp;\n\t\t/* Find our address */\n\t\tstruct atalk_addr *ap = atalk_find_dev_addr(dev);\n\n\t\tif (!ap || skb->len < sizeof(struct ddpshdr))\n\t\t\tgoto freeit;\n\t\t/*\n\t\t * The push leaves us with a ddephdr not an shdr, and\n\t\t * handily the port bytes in the right place preset.\n\t\t */\n\n\t\tskb_push(skb, sizeof(*ddp) - 4);\n\t\t/* FIXME: use skb->cb to be able to use shared skbs */\n\t\tddp = (struct ddpehdr *)skb->data;\n\n\t\t/* Now fill in the long header */\n\n\t \t/*\n\t \t * These two first. The mac overlays the new source/dest\n\t \t * network information so we MUST copy these before\n\t \t * we write the network numbers !\n\t \t */\n\n\t\tddp->deh_dnode = skb->mac.raw[0];     /* From physical header */\n\t\tddp->deh_snode = skb->mac.raw[1];     /* From physical header */\n\n\t\tddp->deh_dnet  = ap->s_net;\t/* Network number */\n\t\tddp->deh_snet  = ap->s_net;\n\t\tddp->deh_sum   = 0;\t\t/* No checksum */\n\t\t/*\n\t\t * Not sure about this bit...\n\t\t */\n\t\tddp->deh_len   = skb->len;\n\t\tddp->deh_hops  = DDP_MAXHOPS;\t/* Non routable, so force a drop\n\t\t\t\t\t\t   if we slip up later */\n\t\t/* Mend the byte order */\n\t\t*((__u16 *)ddp) = htons(*((__u16 *)ddp));\n\t}\n\tskb->h.raw = skb->data;\n\n\treturn atalk_rcv(skb, dev, pt);\nfreeit:\n\tkfree_skb(skb);\n\treturn 0;\n}", "target": 1, "cwe": [], "project": "history", "commit_id": "7ab442d7e0a76402c12553ee256f756097cae2d2", "hash": 19552567024474732272704415128707431614, "size": 50, "message": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets."}
{"func": "static int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt)\n{\n\tstruct ddpehdr *ddp = ddp_hdr(skb);\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n        int origlen;\n        struct ddpebits ddphv;\n\n\t/* Size check */\n\tif (skb->len < sizeof(*ddp))\n\t\tgoto freeit;\n\n\t/*\n\t *\tFix up the length field\t[Ok this is horrible but otherwise\n\t *\tI end up with unions of bit fields and messy bit field order\n\t *\tcompiler/endian dependencies..]\n\t *\n\t *\tFIXME: This is a write to a shared object. Granted it\n\t *\thappens to be safe BUT.. (Its safe as user space will not\n\t *\trun until we put it back)\n\t */\n\t*((__u16 *)&ddphv) = ntohs(*((__u16 *)ddp));\n\n\t/* Trim buffer in case of stray trailing data */\n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, ddphv.deh_len));\n\n\t/*\n\t * Size check to see if ddp->deh_len was crap\n\t * (Otherwise we'll detonate most spectacularly\n\t * in the middle of recvmsg()).\n\t */\n\tif (skb->len < sizeof(*ddp))\n\t\tgoto freeit;\n\n\t/*\n\t * Any checksums. Note we don't do htons() on this == is assumed to be\n\t * valid for net byte orders all over the networking code...\n\t */\n\tif (ddp->deh_sum &&\n\t    atalk_checksum(ddp, ddphv.deh_len) != ddp->deh_sum)\n\t\t/* Not a valid AppleTalk frame - dustbin time */\n\t\tgoto freeit;\n\n\t/* Check the packet is aimed at us */\n\tif (!ddp->deh_dnet)\t/* Net 0 is 'this network' */\n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\t/* Not ours, so we route the packet via the correct AppleTalk iface */\n\tif (!atif) {\n\t\tatalk_route_packet(skb, dev, ddp, &ddphv, origlen);\n\t\tgoto out;\n\t}\n\n\t/* if IP over DDP is not selected this code will be optimized out */\n\tif (is_ip_over_ddp(skb))\n\t\treturn handle_ip_over_ddp(skb);\n\t/*\n\t * Which socket - atalk_search_socket() looks for a *full match*\n\t * of the <net, node, port> tuple.\n\t */\n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock) /* But not one of our sockets */\n\t\tgoto freeit;\n\n\t/* Queue packet (standard) */\n\tskb->sk = sock;\n\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto freeit;\nout:\n\treturn 0;\nfreeit:\n\tkfree_skb(skb);\n\tgoto out;\n}", "target": 1, "cwe": [], "project": "history", "commit_id": "7ab442d7e0a76402c12553ee256f756097cae2d2", "hash": 72319509895917336671439817546429948838, "size": 84, "message": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets."}
{"func": "static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t int len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *usat = (struct sockaddr_at *)msg->msg_name;\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~MSG_DONTWAIT)\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tif (usat) {\n\t\tif (sk->sk_zapped)\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\treturn -EBUSY;\n\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\n\t\t/* netatalk doesn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\tprintk(KERN_INFO \"SO_BROADCAST: Fix your netatalk as \"\n\t\t\t\t\t \"it will break before 2.2\\n\");\n#if 0\n\t\t\treturn -EPERM;\n#endif\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t\tif (!rt)\n\t\t\treturn -ENETUNREACH;\n\n\t\tdev = rt->dev;\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t\tif (!rt)\n\t\t\treturn -ENETUNREACH;\n\n\t\tdev = rt->dev;\n\t}\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tif (!skb)\n\t\treturn err;\n\t\n\tskb->sk = sk;\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_pad  = 0;\n\tddp->deh_hops = 0;\n\tddp->deh_len  = len + sizeof(*ddp);\n\t/*\n\t * Fix up the length field [Ok this is horrible but otherwise\n\t * I end up with unions of bit fields and messy bit field order\n\t * compiler/endian dependencies..\n\t */\n\t*((__u16 *)ddp) = ntohs(*((__u16 *)ddp));\n\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%d bytes).\\n\", sk, len);\n\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sk->sk_no_check == 1)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(ddp, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\tif (aarp_send_ddp(dev, skb2,\n\t\t\t\t\t  &usat->sat_addr, NULL) == -1)\n\t\t\t\tkfree_skb(skb2);\n\t\t\t\t/* else queued/sent above in the aarp queue */\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)\n\t\t\tkfree_skb(skb);\n\t\t/* else queued/sent above in the aarp queue */\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%d).\\n\", sk, len);\n\n\treturn len;\n}", "target": 1, "cwe": [], "project": "history", "commit_id": "7ab442d7e0a76402c12553ee256f756097cae2d2", "hash": 153761947041868070552175845906838763499, "size": 159, "message": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets."}
{"func": "static int fat_ioctl_filldir(void *__buf, const char *name, int name_len,\n\t\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct fat_ioctl_filldir_callback *buf = __buf;\n\tstruct dirent __user *d1 = buf->dirent;\n\tstruct dirent __user *d2 = d1 + 1;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\tbuf->result++;\n\n\tif (name != NULL) {\n\t\t/* dirent has only short name */\n\t\tif (name_len >= sizeof(d1->d_name))\n\t\t\tname_len = sizeof(d1->d_name) - 1;\n\n\t\tif (put_user(0, d2->d_name)\t\t\t||\n\t\t    put_user(0, &d2->d_reclen)\t\t\t||\n\t\t    copy_to_user(d1->d_name, name, name_len)\t||\n\t\t    put_user(0, d1->d_name + name_len)\t\t||\n\t\t    put_user(name_len, &d1->d_reclen))\n\t\t\tgoto efault;\n\t} else {\n\t\t/* dirent has short and long name */\n\t\tconst char *longname = buf->longname;\n\t\tint long_len = buf->long_len;\n\t\tconst char *shortname = buf->shortname;\n\t\tint short_len = buf->short_len;\n\n\t\tif (long_len >= sizeof(d1->d_name))\n\t\t\tlong_len = sizeof(d1->d_name) - 1;\n\t\tif (short_len >= sizeof(d1->d_name))\n\t\t\tshort_len = sizeof(d1->d_name) - 1;\n\n\t\tif (copy_to_user(d2->d_name, longname, long_len)\t||\n\t\t    put_user(0, d2->d_name + long_len)\t\t\t||\n\t\t    put_user(long_len, &d2->d_reclen)\t\t\t||\n\t\t    put_user(ino, &d2->d_ino)\t\t\t\t||\n\t\t    put_user(offset, &d2->d_off)\t\t\t||\n\t\t    copy_to_user(d1->d_name, shortname, short_len)\t||\n\t\t    put_user(0, d1->d_name + short_len)\t\t\t||\n\t\t    put_user(short_len, &d1->d_reclen))\n\t\t\tgoto efault;\n\t}\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "c483bab099cb89e92b7cad94a52fcdaf37e56657", "hash": 187708325882921454075693237509471435333, "size": 49, "message": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int fat_dir_ioctl(struct inode * inode, struct file * filp,\n\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct fat_ioctl_filldir_callback buf;\n\tstruct dirent __user *d1;\n\tint ret, short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(inode, filp, cmd, arg);\n\t}\n\n\td1 = (struct dirent __user *)arg;\n\tif (!access_ok(VERIFY_WRITE, d1, sizeof(struct dirent[2])))\n\t\treturn -EFAULT;\n\t/*\n\t * Yes, we don't need this put_user() absolutely. However old\n\t * code didn't return the right value. So, app use this value,\n\t * in order to check whether it is EOF.\n\t */\n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\tbuf.dirent = d1;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, filp, &buf, fat_ioctl_filldir,\n\t\t\t\t    short_only, both);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "c483bab099cb89e92b7cad94a52fcdaf37e56657", "hash": 113627596617655061806217101411583896910, "size": 44, "message": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static long fat_compat_dir_ioctl(struct file *file, unsigned cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct compat_dirent __user *p = compat_ptr(arg);\n\tint ret;\n\tmm_segment_t oldfs = get_fs();\n\tstruct dirent d[2];\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_BOTH32:\n\t\tcmd = VFAT_IOCTL_READDIR_BOTH;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_SHORT32:\n\t\tcmd = VFAT_IOCTL_READDIR_SHORT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tlock_kernel();\n\tret = fat_dir_ioctl(file->f_path.dentry->d_inode, file,\n\t\t\t    cmd, (unsigned long) &d);\n\tunlock_kernel();\n\tset_fs(oldfs);\n\tif (ret >= 0) {\n\t\tret |= fat_compat_put_dirent32(&d[0], p);\n\t\tret |= fat_compat_put_dirent32(&d[1], p + 1);\n\t}\n\treturn ret;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "c483bab099cb89e92b7cad94a52fcdaf37e56657", "hash": 291589362780422191634012586934810692426, "size": 31, "message": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static long fat_compat_put_dirent32(struct dirent *d,\n\t\t\t\t    struct compat_dirent __user *d32)\n{\n        if (!access_ok(VERIFY_WRITE, d32, sizeof(struct compat_dirent)))\n                return -EFAULT;\n\n        __put_user(d->d_ino, &d32->d_ino);\n        __put_user(d->d_off, &d32->d_off);\n        __put_user(d->d_reclen, &d32->d_reclen);\n        if (__copy_to_user(d32->d_name, d->d_name, d->d_reclen))\n\t\treturn -EFAULT;\n\n        return 0;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "c483bab099cb89e92b7cad94a52fcdaf37e56657", "hash": 106659780049225785767525003746183196183, "size": 14, "message": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int vfat_ioctl32(unsigned fd, unsigned cmd, unsigned long arg)\n{\n\tstruct compat_dirent __user *p = compat_ptr(arg);\n\tint ret;\n\tmm_segment_t oldfs = get_fs();\n\tstruct dirent d[2];\n\n\tswitch(cmd)\n\t{\n        \tcase VFAT_IOCTL_READDIR_BOTH32:\n                \tcmd = VFAT_IOCTL_READDIR_BOTH;\n                \tbreak;\n        \tcase VFAT_IOCTL_READDIR_SHORT32:\n                \tcmd = VFAT_IOCTL_READDIR_SHORT;\n                \tbreak;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tret = sys_ioctl(fd,cmd,(unsigned long)&d);\n\tset_fs(oldfs);\n\tif (ret >= 0) {\n\t\tret |= put_dirent32(&d[0], p);\n\t\tret |= put_dirent32(&d[1], p + 1);\n\t}\n\treturn ret;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "188f83dfe0eeecd1427d0d255cc97dbf7ef6b4b7", "hash": 111898724151179411964972445082613411107, "size": 26, "message": "[PATCH] BLOCK: Move the msdos device ioctl compat stuff to the msdos driver [try #6]\n\nMove the msdos device ioctl compat stuff from fs/compat_ioctl.c to the msdos\ndriver so that the msdos header file doesn't need to be included.\n\nSigned-Off-By: David Howells <dhowells@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>"}
{"func": "put_dirent32 (struct dirent *d, struct compat_dirent __user *d32)\n{\n        if (!access_ok(VERIFY_WRITE, d32, sizeof(struct compat_dirent)))\n                return -EFAULT;\n\n        __put_user(d->d_ino, &d32->d_ino);\n        __put_user(d->d_off, &d32->d_off);\n        __put_user(d->d_reclen, &d32->d_reclen);\n        if (__copy_to_user(d32->d_name, d->d_name, d->d_reclen))\n\t\treturn -EFAULT;\n\n        return 0;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "188f83dfe0eeecd1427d0d255cc97dbf7ef6b4b7", "hash": 270045642335722159449853839682351083428, "size": 13, "message": "[PATCH] BLOCK: Move the msdos device ioctl compat stuff to the msdos driver [try #6]\n\nMove the msdos device ioctl compat stuff from fs/compat_ioctl.c to the msdos\ndriver so that the msdos header file doesn't need to be included.\n\nSigned-Off-By: David Howells <dhowells@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>"}
{"func": "unsigned long convert_rip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->rip;\n\tseg = regs->cs & 0xffff;\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "29eb51101c02df517ca64ec472d7501127ad1da8", "hash": 1508545436095858671693183645763265341, "size": 29, "message": "Handle bogus %cs selector in single-step instruction decoding\n\nThe code for LDT segment selectors was not robust in the face of a bogus\nselector set in %cs via ptrace before the single-step was done.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->eip;\n\tseg = regs->xcs & 0xffff;\n\tif (regs->eflags & VM_MASK) {\n\t\taddr = (addr & 0xffff) + (seg << 4);\n\t\treturn addr;\n\t}\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "29eb51101c02df517ca64ec472d7501127ad1da8", "hash": 106350190623619753707189764532983232553, "size": 33, "message": "Handle bogus %cs selector in single-step instruction decoding\n\nThe code for LDT segment selectors was not robust in the face of a bogus\nselector set in %cs via ptrace before the single-step was done.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "pfm_smpl_buffer_alloc(struct task_struct *task, pfm_context_t *ctx, unsigned long rsize, void **user_vaddr)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tunsigned long size;\n\tvoid *smpl_buf;\n\n\n\t/*\n\t * the fixed header + requested size and align to page boundary\n\t */\n\tsize = PAGE_ALIGN(rsize);\n\n\tDPRINT((\"sampling buffer rsize=%lu size=%lu bytes\\n\", rsize, size));\n\n\t/*\n\t * check requested size to avoid Denial-of-service attacks\n\t * XXX: may have to refine this test\n\t * Check against address space limit.\n\t *\n\t * if ((mm->total_vm << PAGE_SHIFT) + len> task->rlim[RLIMIT_AS].rlim_cur)\n\t * \treturn -ENOMEM;\n\t */\n\tif (size > task->signal->rlim[RLIMIT_MEMLOCK].rlim_cur)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We do the easy to undo allocations first.\n \t *\n\t * pfm_rvmalloc(), clears the buffer, so there is no leak\n\t */\n\tsmpl_buf = pfm_rvmalloc(size);\n\tif (smpl_buf == NULL) {\n\t\tDPRINT((\"Can't allocate sampling buffer\\n\"));\n\t\treturn -ENOMEM;\n\t}\n\n\tDPRINT((\"smpl_buf @%p\\n\", smpl_buf));\n\n\t/* allocate vma */\n\tvma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n\tif (!vma) {\n\t\tDPRINT((\"Cannot allocate vma\\n\"));\n\t\tgoto error_kmem;\n\t}\n\n\t/*\n\t * partially initialize the vma for the sampling buffer\n\t */\n\tvma->vm_mm\t     = mm;\n\tvma->vm_flags\t     = VM_READ| VM_MAYREAD |VM_RESERVED;\n\tvma->vm_page_prot    = PAGE_READONLY; /* XXX may need to change */\n\n\t/*\n\t * Now we have everything we need and we can initialize\n\t * and connect all the data structures\n\t */\n\n\tctx->ctx_smpl_hdr   = smpl_buf;\n\tctx->ctx_smpl_size  = size; /* aligned size */\n\n\t/*\n\t * Let's do the difficult operations next.\n\t *\n\t * now we atomically find some area in the address space and\n\t * remap the buffer in it.\n\t */\n\tdown_write(&task->mm->mmap_sem);\n\n\t/* find some free area in address space, must have mmap sem held */\n\tvma->vm_start = pfm_get_unmapped_area(NULL, 0, size, 0, MAP_PRIVATE|MAP_ANONYMOUS, 0);\n\tif (vma->vm_start == 0UL) {\n\t\tDPRINT((\"Cannot find unmapped area for size %ld\\n\", size));\n\t\tup_write(&task->mm->mmap_sem);\n\t\tgoto error;\n\t}\n\tvma->vm_end = vma->vm_start + size;\n\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\n\tDPRINT((\"aligned size=%ld, hdr=%p mapped @0x%lx\\n\", size, ctx->ctx_smpl_hdr, vma->vm_start));\n\n\t/* can only be applied to current task, need to have the mm semaphore held when called */\n\tif (pfm_remap_buffer(vma, (unsigned long)smpl_buf, vma->vm_start, size)) {\n\t\tDPRINT((\"Can't remap buffer\\n\"));\n\t\tup_write(&task->mm->mmap_sem);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * now insert the vma in the vm list for the process, must be\n\t * done with mmap lock held\n\t */\n\tinsert_vm_struct(mm, vma);\n\n\tmm->total_vm  += size >> PAGE_SHIFT;\n\tvm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file,\n\t\t\t\t\t\t\tvma_pages(vma));\n\tup_write(&task->mm->mmap_sem);\n\n\t/*\n\t * keep track of user level virtual address\n\t */\n\tctx->ctx_smpl_vaddr = (void *)vma->vm_start;\n\t*(unsigned long *)user_vaddr = vma->vm_start;\n\n\treturn 0;\n\nerror:\n\tkmem_cache_free(vm_area_cachep, vma);\nerror_kmem:\n\tpfm_rvfree(smpl_buf, size);\n\n\treturn -ENOMEM;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "41d5e5d73ecef4ef56b7b4cde962929a712689b4", "hash": 87803820803317589966380178034337365249, "size": 114, "message": "[IA64] permon use-after-free fix\n\nPerfmon associates vmalloc()ed memory with a file descriptor, and installs\na vma mapping that memory.  Unfortunately, the vm_file field is not filled\nin, so processes with mappings to that memory do not prevent the file from\nbeing closed and the memory freed.  This results in use-after-free bugs and\nmultiple freeing of pages, etc.\n\nI saw this bug on an Altix on SLES9.  Haven't reproduced upstream but it\nlooks like the same issue is there.\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nCc: Stephane Eranian <eranian@hpl.hp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Tony Luck <tony.luck@intel.com>"}
{"func": "pfm_context_create(pfm_context_t *ctx, void *arg, int count, struct pt_regs *regs)\n{\n\tpfarg_context_t *req = (pfarg_context_t *)arg;\n\tstruct file *filp;\n\tint ctx_flags;\n\tint ret;\n\n\t/* let's check the arguments first */\n\tret = pfarg_is_sane(current, req);\n\tif (ret < 0) return ret;\n\n\tctx_flags = req->ctx_flags;\n\n\tret = -ENOMEM;\n\n\tctx = pfm_context_alloc();\n\tif (!ctx) goto error;\n\n\tret = pfm_alloc_fd(&filp);\n\tif (ret < 0) goto error_file;\n\n\treq->ctx_fd = ctx->ctx_fd = ret;\n\n\t/*\n\t * attach context to file\n\t */\n\tfilp->private_data = ctx;\n\n\t/*\n\t * does the user want to sample?\n\t */\n\tif (pfm_uuid_cmp(req->ctx_smpl_buf_id, pfm_null_uuid)) {\n\t\tret = pfm_setup_buffer_fmt(current, ctx, ctx_flags, 0, req);\n\t\tif (ret) goto buffer_error;\n\t}\n\n\t/*\n\t * init context protection lock\n\t */\n\tspin_lock_init(&ctx->ctx_lock);\n\n\t/*\n\t * context is unloaded\n\t */\n\tctx->ctx_state = PFM_CTX_UNLOADED;\n\n\t/*\n\t * initialization of context's flags\n\t */\n\tctx->ctx_fl_block       = (ctx_flags & PFM_FL_NOTIFY_BLOCK) ? 1 : 0;\n\tctx->ctx_fl_system      = (ctx_flags & PFM_FL_SYSTEM_WIDE) ? 1: 0;\n\tctx->ctx_fl_is_sampling = ctx->ctx_buf_fmt ? 1 : 0; /* assume record() is defined */\n\tctx->ctx_fl_no_msg      = (ctx_flags & PFM_FL_OVFL_NO_MSG) ? 1: 0;\n\t/*\n\t * will move to set properties\n\t * ctx->ctx_fl_excl_idle   = (ctx_flags & PFM_FL_EXCL_IDLE) ? 1: 0;\n\t */\n\n\t/*\n\t * init restart semaphore to locked\n\t */\n\tinit_completion(&ctx->ctx_restart_done);\n\n\t/*\n\t * activation is used in SMP only\n\t */\n\tctx->ctx_last_activation = PFM_INVALID_ACTIVATION;\n\tSET_LAST_CPU(ctx, -1);\n\n\t/*\n\t * initialize notification message queue\n\t */\n\tctx->ctx_msgq_head = ctx->ctx_msgq_tail = 0;\n\tinit_waitqueue_head(&ctx->ctx_msgq_wait);\n\tinit_waitqueue_head(&ctx->ctx_zombieq);\n\n\tDPRINT((\"ctx=%p flags=0x%x system=%d notify_block=%d excl_idle=%d no_msg=%d ctx_fd=%d \\n\",\n\t\tctx,\n\t\tctx_flags,\n\t\tctx->ctx_fl_system,\n\t\tctx->ctx_fl_block,\n\t\tctx->ctx_fl_excl_idle,\n\t\tctx->ctx_fl_no_msg,\n\t\tctx->ctx_fd));\n\n\t/*\n\t * initialize soft PMU state\n\t */\n\tpfm_reset_pmu_state(ctx);\n\n\treturn 0;\n\nbuffer_error:\n\tpfm_free_fd(ctx->ctx_fd, filp);\n\n\tif (ctx->ctx_buf_fmt) {\n\t\tpfm_buf_fmt_exit(ctx->ctx_buf_fmt, current, NULL, regs);\n\t}\nerror_file:\n\tpfm_context_free(ctx);\n\nerror:\n\treturn ret;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "41d5e5d73ecef4ef56b7b4cde962929a712689b4", "hash": 13520750174224364535947939006635351369, "size": 104, "message": "[IA64] permon use-after-free fix\n\nPerfmon associates vmalloc()ed memory with a file descriptor, and installs\na vma mapping that memory.  Unfortunately, the vm_file field is not filled\nin, so processes with mappings to that memory do not prevent the file from\nbeing closed and the memory freed.  This results in use-after-free bugs and\nmultiple freeing of pages, etc.\n\nI saw this bug on an Altix on SLES9.  Haven't reproduced upstream but it\nlooks like the same issue is there.\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nCc: Stephane Eranian <eranian@hpl.hp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Tony Luck <tony.luck@intel.com>"}
{"func": "pfm_setup_buffer_fmt(struct task_struct *task, pfm_context_t *ctx, unsigned int ctx_flags,\n\t\t     unsigned int cpu, pfarg_context_t *arg)\n{\n\tpfm_buffer_fmt_t *fmt = NULL;\n\tunsigned long size = 0UL;\n\tvoid *uaddr = NULL;\n\tvoid *fmt_arg = NULL;\n\tint ret = 0;\n#define PFM_CTXARG_BUF_ARG(a)\t(pfm_buffer_fmt_t *)(a+1)\n\n\t/* invoke and lock buffer format, if found */\n\tfmt = pfm_find_buffer_fmt(arg->ctx_smpl_buf_id);\n\tif (fmt == NULL) {\n\t\tDPRINT((\"[%d] cannot find buffer format\\n\", task->pid));\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * buffer argument MUST be contiguous to pfarg_context_t\n\t */\n\tif (fmt->fmt_arg_size) fmt_arg = PFM_CTXARG_BUF_ARG(arg);\n\n\tret = pfm_buf_fmt_validate(fmt, task, ctx_flags, cpu, fmt_arg);\n\n\tDPRINT((\"[%d] after validate(0x%x,%d,%p)=%d\\n\", task->pid, ctx_flags, cpu, fmt_arg, ret));\n\n\tif (ret) goto error;\n\n\t/* link buffer format and context */\n\tctx->ctx_buf_fmt = fmt;\n\n\t/*\n\t * check if buffer format wants to use perfmon buffer allocation/mapping service\n\t */\n\tret = pfm_buf_fmt_getsize(fmt, task, ctx_flags, cpu, fmt_arg, &size);\n\tif (ret) goto error;\n\n\tif (size) {\n\t\t/*\n\t\t * buffer is always remapped into the caller's address space\n\t\t */\n\t\tret = pfm_smpl_buffer_alloc(current, ctx, size, &uaddr);\n\t\tif (ret) goto error;\n\n\t\t/* keep track of user address of buffer */\n\t\targ->ctx_smpl_vaddr = uaddr;\n\t}\n\tret = pfm_buf_fmt_init(fmt, task, ctx->ctx_smpl_hdr, ctx_flags, cpu, fmt_arg);\n\nerror:\n\treturn ret;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "41d5e5d73ecef4ef56b7b4cde962929a712689b4", "hash": 46202394531124018831417285404810810597, "size": 52, "message": "[IA64] permon use-after-free fix\n\nPerfmon associates vmalloc()ed memory with a file descriptor, and installs\na vma mapping that memory.  Unfortunately, the vm_file field is not filled\nin, so processes with mappings to that memory do not prevent the file from\nbeing closed and the memory freed.  This results in use-after-free bugs and\nmultiple freeing of pages, etc.\n\nI saw this bug on an Altix on SLES9.  Haven't reproduced upstream but it\nlooks like the same issue is there.\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nCc: Stephane Eranian <eranian@hpl.hp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Tony Luck <tony.luck@intel.com>"}
{"func": "static int __init snd_mem_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tsnd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);\n\tif (snd_mem_proc) {\n\t\tsnd_mem_proc->read_proc = snd_mem_proc_read;\n#ifdef CONFIG_PCI\n\t\tsnd_mem_proc->write_proc = snd_mem_proc_write;\n#endif\n\t}\n#endif\n\treturn 0;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "ccec6e2c4a74adf76ed4e2478091a311b1806212", "hash": 6222875397067194352861204548094447265, "size": 13, "message": "Convert snd-page-alloc proc file to use seq_file\n\nUse seq_file for the proc file read/write of snd-page-alloc module.\nThis automatically fixes bugs in the old proc code.\n\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int snd_mem_proc_read(char *page, char **start, off_t off,\n\t\t\t     int count, int *eof, void *data)\n{\n\tint len = 0;\n\tlong pages = snd_allocated_pages >> (PAGE_SHIFT-12);\n\tstruct snd_mem_list *mem;\n\tint devno;\n\tstatic char *types[] = { \"UNKNOWN\", \"CONT\", \"DEV\", \"DEV-SG\", \"SBUS\" };\n\n\tmutex_lock(&list_mutex);\n\tlen += snprintf(page + len, count - len,\n\t\t\t\"pages  : %li bytes (%li pages per %likB)\\n\",\n\t\t\tpages * PAGE_SIZE, pages, PAGE_SIZE / 1024);\n\tdevno = 0;\n\tlist_for_each_entry(mem, &mem_list_head, list) {\n\t\tdevno++;\n\t\tlen += snprintf(page + len, count - len,\n\t\t\t\t\"buffer %d : ID %08x : type %s\\n\",\n\t\t\t\tdevno, mem->id, types[mem->buffer.dev.type]);\n\t\tlen += snprintf(page + len, count - len,\n\t\t\t\t\"  addr = 0x%lx, size = %d bytes\\n\",\n\t\t\t\t(unsigned long)mem->buffer.addr, (int)mem->buffer.bytes);\n\t}\n\tmutex_unlock(&list_mutex);\n\treturn len;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "ccec6e2c4a74adf76ed4e2478091a311b1806212", "hash": 177539223428479219345960137138678283235, "size": 26, "message": "Convert snd-page-alloc proc file to use seq_file\n\nUse seq_file for the proc file read/write of snd-page-alloc module.\nThis automatically fixes bugs in the old proc code.\n\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int snd_mem_proc_write(struct file *file, const char __user *buffer,\n\t\t\t      unsigned long count, void *data)\n{\n\tchar buf[128];\n\tchar *token, *p;\n\n\tif (count > ARRAY_SIZE(buf) - 1)\n\t\tcount = ARRAY_SIZE(buf) - 1;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\tbuf[ARRAY_SIZE(buf) - 1] = '\\0';\n\n\tp = buf;\n\ttoken = gettoken(&p);\n\tif (! token || *token == '#')\n\t\treturn (int)count;\n\tif (strcmp(token, \"add\") == 0) {\n\t\tchar *endp;\n\t\tint vendor, device, size, buffers;\n\t\tlong mask;\n\t\tint i, alloced;\n\t\tstruct pci_dev *pci;\n\n\t\tif ((token = gettoken(&p)) == NULL ||\n\t\t    (vendor = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (device = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (mask = simple_strtol(token, NULL, 0)) < 0 ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (size = memparse(token, &endp)) < 64*1024 ||\n\t\t    size > 16*1024*1024 /* too big */ ||\n\t\t    (token = gettoken(&p)) == NULL ||\n\t\t    (buffers = simple_strtol(token, NULL, 0)) <= 0 ||\n\t\t    buffers > 4) {\n\t\t\tprintk(KERN_ERR \"snd-page-alloc: invalid proc write format\\n\");\n\t\t\treturn (int)count;\n\t\t}\n\t\tvendor &= 0xffff;\n\t\tdevice &= 0xffff;\n\n\t\talloced = 0;\n\t\tpci = NULL;\n\t\twhile ((pci = pci_get_device(vendor, device, pci)) != NULL) {\n\t\t\tif (mask > 0 && mask < 0xffffffff) {\n\t\t\t\tif (pci_set_dma_mask(pci, mask) < 0 ||\n\t\t\t\t    pci_set_consistent_dma_mask(pci, mask) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot set DMA mask %lx for pci %04x:%04x\\n\", mask, vendor, device);\n\t\t\t\t\treturn (int)count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < buffers; i++) {\n\t\t\t\tstruct snd_dma_buffer dmab;\n\t\t\t\tmemset(&dmab, 0, sizeof(dmab));\n\t\t\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\n\t\t\t\t\t\t\tsize, &dmab) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot allocate buffer pages (size = %d)\\n\", size);\n\t\t\t\t\tpci_dev_put(pci);\n\t\t\t\t\treturn (int)count;\n\t\t\t\t}\n\t\t\t\tsnd_dma_reserve_buf(&dmab, snd_dma_pci_buf_id(pci));\n\t\t\t}\n\t\t\talloced++;\n\t\t}\n\t\tif (! alloced) {\n\t\t\tfor (i = 0; i < buffers; i++) {\n\t\t\t\tstruct snd_dma_buffer dmab;\n\t\t\t\tmemset(&dmab, 0, sizeof(dmab));\n\t\t\t\t/* FIXME: We can allocate only in ZONE_DMA\n\t\t\t\t * without a device pointer!\n\t\t\t\t */\n\t\t\t\tif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, NULL,\n\t\t\t\t\t\t\tsize, &dmab) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"snd-page-alloc: cannot allocate buffer pages (size = %d)\\n\", size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsnd_dma_reserve_buf(&dmab, (unsigned int)((vendor << 16) | device));\n\t\t\t}\n\t\t}\n\t} else if (strcmp(token, \"erase\") == 0)\n\t\t/* FIXME: need for releasing each buffer chunk? */\n\t\tfree_all_reserved_pages();\n\telse\n\t\tprintk(KERN_ERR \"snd-page-alloc: invalid proc cmd\\n\");\n\treturn (int)count;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "ccec6e2c4a74adf76ed4e2478091a311b1806212", "hash": 309883721051093126401462833357401098731, "size": 86, "message": "Convert snd-page-alloc proc file to use seq_file\n\nUse seq_file for the proc file read/write of snd-page-alloc module.\nThis automatically fixes bugs in the old proc code.\n\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int putreg(struct task_struct *child,\n\tunsigned long regno, unsigned long value)\n{\n\tunsigned long tmp; \n\t\n\t/* Some code in the 64bit emulation may not be 64bit clean.\n\t   Don't take any chances. */\n\tif (test_tsk_thread_flag(child, TIF_IA32))\n\t\tvalue &= 0xffffffff;\n\tswitch (regno) {\n\t\tcase offsetof(struct user_regs_struct,fs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fsindex = value & 0xffff; \n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gsindex = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ds):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.ds = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,es): \n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.es = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ss):\n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,fs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct, eflags):\n\t\t\tvalue &= FLAG_MASK;\n\t\t\ttmp = get_stack_long(child, EFL_OFFSET); \n\t\t\ttmp &= ~FLAG_MASK; \n\t\t\tvalue |= tmp;\n\t\t\tbreak;\n\t\tcase offsetof(struct user_regs_struct,cs): \n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\tbreak;\n\t}\n\tput_stack_long(child, regno - sizeof(struct pt_regs), value);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-264"], "project": "linux-2.6", "commit_id": "176df2457ef6207156ca1a40991c54ca01fef567", "hash": 118245962164453333133896654852307172628, "size": 60, "message": "x86_64: Zero extend all registers after ptrace in 32bit entry path.\n\nStrictly it's only needed for eax.\n\nIt actually does a little more than strictly needed -- the other registers\nare already zero extended.\n\nAlso remove the now unnecessary and non functional compat task check\nin ptrace.\n\nThis is CVE-2007-4573\n\nFound by Wojciech Purczynski\n\nSigned-off-by: Andi Kleen <ak@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int pwc_video_close(struct inode *inode, struct file *file)\n{\n\tstruct video_device *vdev = file->private_data;\n\tstruct pwc_device *pdev;\n\tint i;\n\n\tPWC_DEBUG_OPEN(\">> video_close called(vdev = 0x%p).\\n\", vdev);\n\n\tpdev = (struct pwc_device *)vdev->priv;\n\tif (pdev->vopen == 0)\n\t\tPWC_DEBUG_MODULE(\"video_close() called on closed device?\\n\");\n\n\t/* Dump statistics, but only if a reasonable amount of frames were\n\t   processed (to prevent endless log-entries in case of snap-shot\n\t   programs)\n\t */\n\tif (pdev->vframe_count > 20)\n\t\tPWC_DEBUG_MODULE(\"Closing video device: %d frames received, dumped %d frames, %d frames with errors.\\n\", pdev->vframe_count, pdev->vframes_dumped, pdev->vframes_error);\n\n\tif (DEVICE_USE_CODEC1(pdev->type))\n\t    pwc_dec1_exit();\n\telse\n\t    pwc_dec23_exit();\n\n\tpwc_isoc_cleanup(pdev);\n\tpwc_free_buffers(pdev);\n\n\t/* Turn off LEDS and power down camera, but only when not unplugged */\n\tif (pdev->error_status != EPIPE) {\n\t\t/* Turn LEDs off */\n\t\tif (pwc_set_leds(pdev, 0, 0) < 0)\n\t\t\tPWC_DEBUG_MODULE(\"Failed to set LED on/off time.\\n\");\n\t\tif (power_save) {\n\t\t\ti = pwc_camera_power(pdev, 0);\n\t\t\tif (i < 0)\n\t\t\t\tPWC_ERROR(\"Failed to power down camera (%d)\\n\", i);\n\t\t}\n\t}\n\tpdev->vopen--;\n\tPWC_DEBUG_OPEN(\"<< video_close() vopen=%d\\n\", pdev->vopen);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "85237f202d46d55c1bffe0c5b1aa3ddc0f1dce4d", "hash": 124682724723247590310182780943974549817, "size": 42, "message": "USB: fix DoS in pwc USB video driver\n\nthe pwc driver has a disconnect method that waits for user space to\nclose the device. This opens up an opportunity for a DoS attack,\nblocking the USB subsystem and making khubd's task busy wait in\nkernel space. This patch shifts freeing resources to close if an opened\ndevice is disconnected.\n\nSigned-off-by: Oliver Neukum <oneukum@suse.de>\nCC: stable <stable@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>"}
{"func": "static void usb_pwc_disconnect(struct usb_interface *intf)\n{\n\tstruct pwc_device *pdev;\n\tint hint;\n\n\tlock_kernel();\n\tpdev = usb_get_intfdata (intf);\n\tusb_set_intfdata (intf, NULL);\n\tif (pdev == NULL) {\n\t\tPWC_ERROR(\"pwc_disconnect() Called without private pointer.\\n\");\n\t\tgoto disconnect_out;\n\t}\n\tif (pdev->udev == NULL) {\n\t\tPWC_ERROR(\"pwc_disconnect() already called for %p\\n\", pdev);\n\t\tgoto disconnect_out;\n\t}\n\tif (pdev->udev != interface_to_usbdev(intf)) {\n\t\tPWC_ERROR(\"pwc_disconnect() Woops: pointer mismatch udev/pdev.\\n\");\n\t\tgoto disconnect_out;\n\t}\n\n\t/* We got unplugged; this is signalled by an EPIPE error code */\n\tif (pdev->vopen) {\n\t\tPWC_INFO(\"Disconnected while webcam is in use!\\n\");\n\t\tpdev->error_status = EPIPE;\n\t}\n\n\t/* Alert waiting processes */\n\twake_up_interruptible(&pdev->frameq);\n\t/* Wait until device is closed */\n\twhile (pdev->vopen)\n\t\tschedule();\n\t/* Device is now closed, so we can safely unregister it */\n\tPWC_DEBUG_PROBE(\"Unregistering video device in disconnect().\\n\");\n\tpwc_remove_sysfs_files(pdev->vdev);\n\tvideo_unregister_device(pdev->vdev);\n\n\t/* Free memory (don't set pdev to 0 just yet) */\n\tkfree(pdev);\n\ndisconnect_out:\n\t/* search device_hint[] table if we occupy a slot, by any chance */\n\tfor (hint = 0; hint < MAX_DEV_HINTS; hint++)\n\t\tif (device_hint[hint].pdev == pdev)\n\t\t\tdevice_hint[hint].pdev = NULL;\n\n\tunlock_kernel();\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "85237f202d46d55c1bffe0c5b1aa3ddc0f1dce4d", "hash": 73412740084702268395071715055708958170, "size": 48, "message": "USB: fix DoS in pwc USB video driver\n\nthe pwc driver has a disconnect method that waits for user space to\nclose the device. This opens up an opportunity for a DoS attack,\nblocking the USB subsystem and making khubd's task busy wait in\nkernel space. This patch shifts freeing resources to close if an opened\ndevice is disconnected.\n\nSigned-off-by: Oliver Neukum <oneukum@suse.de>\nCC: stable <stable@kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>"}
{"func": "static int return_EIO(void)\n{\n\treturn -EIO;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "be6aab0e9fa6d3c6d75aa1e38ac972d8b4ee82b8", "hash": 96018639668712651740578198950715256807, "size": 4, "message": "[PATCH] fix memory corruption from misinterpreted bad_inode_ops return values\n\nCVE-2006-5753 is for a case where an inode can be marked bad, switching\nthe ops to bad_inode_ops, which are all connected as:\n\nstatic int return_EIO(void)\n{\n        return -EIO;\n}\n\n#define EIO_ERROR ((void *) (return_EIO))\n\nstatic struct inode_operations bad_inode_ops =\n{\n        .create         = bad_inode_create\n...etc...\n\nThe problem here is that the void cast causes return types to not be\npromoted, and for ops such as listxattr which expect more than 32 bits of\nreturn value, the 32-bit -EIO is interpreted as a large positive 64-bit\nnumber, i.e. 0x00000000fffffffa instead of 0xfffffffa.\n\nThis goes particularly badly when the return value is taken as a number of\nbytes to copy into, say, a user's buffer for example...\n\nI originally had coded up the fix by creating a return_EIO_<TYPE> macro\nfor each return type, like this:\n\nstatic int return_EIO_int(void)\n{\n\treturn -EIO;\n}\n#define EIO_ERROR_INT ((void *) (return_EIO_int))\n\nstatic struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= EIO_ERROR_INT,\n...etc...\n\nbut Al felt that it was probably better to create an EIO-returner for each\nactual op signature.  Since so few ops share a signature, I just went ahead\n& created an EIO function for each individual file & inode op that returns\na value.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "void make_bad_inode(struct inode * inode) \n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "be6aab0e9fa6d3c6d75aa1e38ac972d8b4ee82b8", "hash": 324712412023376655821555259142241889315, "size": 10, "message": "[PATCH] fix memory corruption from misinterpreted bad_inode_ops return values\n\nCVE-2006-5753 is for a case where an inode can be marked bad, switching\nthe ops to bad_inode_ops, which are all connected as:\n\nstatic int return_EIO(void)\n{\n        return -EIO;\n}\n\n#define EIO_ERROR ((void *) (return_EIO))\n\nstatic struct inode_operations bad_inode_ops =\n{\n        .create         = bad_inode_create\n...etc...\n\nThe problem here is that the void cast causes return types to not be\npromoted, and for ops such as listxattr which expect more than 32 bits of\nreturn value, the 32-bit -EIO is interpreted as a large positive 64-bit\nnumber, i.e. 0x00000000fffffffa instead of 0xfffffffa.\n\nThis goes particularly badly when the return value is taken as a number of\nbytes to copy into, say, a user's buffer for example...\n\nI originally had coded up the fix by creating a return_EIO_<TYPE> macro\nfor each return type, like this:\n\nstatic int return_EIO_int(void)\n{\n\treturn -EIO;\n}\n#define EIO_ERROR_INT ((void *) (return_EIO_int))\n\nstatic struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= EIO_ERROR_INT,\n...etc...\n\nbut Al felt that it was probably better to create an EIO-returner for each\nactual op signature.  Since so few ops share a signature, I just went ahead\n& created an EIO function for each individual file & inode op that returns\na value.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "int is_bad_inode(struct inode * inode) \n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "be6aab0e9fa6d3c6d75aa1e38ac972d8b4ee82b8", "hash": 274069347086903071473148868064705582935, "size": 4, "message": "[PATCH] fix memory corruption from misinterpreted bad_inode_ops return values\n\nCVE-2006-5753 is for a case where an inode can be marked bad, switching\nthe ops to bad_inode_ops, which are all connected as:\n\nstatic int return_EIO(void)\n{\n        return -EIO;\n}\n\n#define EIO_ERROR ((void *) (return_EIO))\n\nstatic struct inode_operations bad_inode_ops =\n{\n        .create         = bad_inode_create\n...etc...\n\nThe problem here is that the void cast causes return types to not be\npromoted, and for ops such as listxattr which expect more than 32 bits of\nreturn value, the 32-bit -EIO is interpreted as a large positive 64-bit\nnumber, i.e. 0x00000000fffffffa instead of 0xfffffffa.\n\nThis goes particularly badly when the return value is taken as a number of\nbytes to copy into, say, a user's buffer for example...\n\nI originally had coded up the fix by creating a return_EIO_<TYPE> macro\nfor each return type, like this:\n\nstatic int return_EIO_int(void)\n{\n\treturn -EIO;\n}\n#define EIO_ERROR_INT ((void *) (return_EIO_int))\n\nstatic struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= EIO_ERROR_INT,\n...etc...\n\nbut Al felt that it was probably better to create an EIO-returner for each\nactual op signature.  Since so few ops share a signature, I just went ahead\n& created an EIO function for each individual file & inode op that returns\na value.\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>"}
{"func": "void hash_preload(struct mm_struct *mm, unsigned long ea,\n\t\t  unsigned long access, unsigned long trap)\n{\n\tunsigned long vsid;\n\tvoid *pgdir;\n\tpte_t *ptep;\n\tcpumask_t mask;\n\tunsigned long flags;\n\tint local = 0;\n\n\t/* We don't want huge pages prefaulted for now\n\t */\n\tif (unlikely(in_hugepage_area(mm->context, ea)))\n\t\treturn;\n\n\tDBG_LOW(\"hash_preload(mm=%p, mm->pgdir=%p, ea=%016lx, access=%lx,\"\n\t\t\" trap=%lx\\n\", mm, mm->pgd, ea, access, trap);\n\n\t/* Get PTE, VSID, access mask */\n\tpgdir = mm->pgd;\n\tif (pgdir == NULL)\n\t\treturn;\n\tptep = find_linux_pte(pgdir, ea);\n\tif (!ptep)\n\t\treturn;\n\tvsid = get_vsid(mm->context.id, ea);\n\n\t/* Hash it in */\n\tlocal_irq_save(flags);\n\tmask = cpumask_of_cpu(smp_processor_id());\n\tif (cpus_equal(mm->cpu_vm_mask, mask))\n\t\tlocal = 1;\n#ifndef CONFIG_PPC_64K_PAGES\n\t__hash_page_4K(ea, access, vsid, ptep, trap, local);\n#else\n\tif (mmu_ci_restrictions) {\n\t\t/* If this PTE is non-cacheable, switch to 4k */\n\t\tif (mm->context.user_psize == MMU_PAGE_64K &&\n\t\t    (pte_val(*ptep) & _PAGE_NO_CACHE)) {\n\t\t\tmm->context.user_psize = MMU_PAGE_4K;\n\t\t\tmm->context.sllp = SLB_VSID_USER |\n\t\t\t\tmmu_psize_defs[MMU_PAGE_4K].sllp;\n\t\t\tget_paca()->context = mm->context;\n\t\t\tslb_flush_and_rebolt();\n#ifdef CONFIG_SPE_BASE\n\t\t\tspu_flush_all_slbs(mm);\n#endif\n\t\t}\n\t}\n\tif (mm->context.user_psize == MMU_PAGE_64K)\n\t\t__hash_page_64K(ea, access, vsid, ptep, trap, local);\n\telse\n\t\t__hash_page_4K(ea, access, vsid, ptep, trap, local);\n#endif /* CONFIG_PPC_64K_PAGES */\n\tlocal_irq_restore(flags);\n}", "target": 1, "cwe": ["CWE-200"], "project": "linux-2.6", "commit_id": "721151d004dcf01a71b12bb6b893f9160284cf6e", "hash": 283712393711387453956188968218825085417, "size": 56, "message": "[POWERPC] Allow drivers to map individual 4k pages to userspace\n\nSome drivers have resources that they want to be able to map into\nuserspace that are 4k in size.  On a kernel configured with 64k pages\nwe currently end up mapping the 4k we want plus another 60k of\nphysical address space, which could contain anything.  This can\nintroduce security problems, for example in the case of an infiniband\nadaptor where the other 60k could contain registers that some other\nprogram is using for its communications.\n\nThis patch adds a new function, remap_4k_pfn, which drivers can use to\nmap a single 4k page to userspace regardless of whether the kernel is\nusing a 4k or a 64k page size.  Like remap_pfn_range, it would\ntypically be called in a driver's mmap function.  It only maps a\nsingle 4k page, which on a 64k page kernel appears replicated 16 times\nthroughout a 64k page.  On a 4k page kernel it reduces to a call to\nremap_pfn_range.\n\nThe way this works on a 64k kernel is that a new bit, _PAGE_4K_PFN,\ngets set on the linux PTE.  This alters the way that __hash_page_4K\ncomputes the real address to put in the HPTE.  The RPN field of the\nlinux PTE becomes the 4k RPN directly rather than being interpreted as\na 64k RPN.  Since the RPN field is 32 bits, this means that physical\naddresses being mapped with remap_4k_pfn have to be below 2^44,\ni.e. 0x100000000000.\n\nThe patch also factors out the code in arch/powerpc/mm/hash_utils_64.c\nthat deals with demoting a process to use 4k pages into one function\nthat gets called in the various different places where we need to do\nthat.  There were some discrepancies between exactly what was done in\nthe various places, such as a call to spu_flush_all_slbs in one case\nbut not in others.\n\nSigned-off-by: Paul Mackerras <paulus@samba.org>"}
{"func": "int hash_page(unsigned long ea, unsigned long access, unsigned long trap)\n{\n\tvoid *pgdir;\n\tunsigned long vsid;\n\tstruct mm_struct *mm;\n\tpte_t *ptep;\n\tcpumask_t tmp;\n\tint rc, user_region = 0, local = 0;\n\tint psize;\n\n\tDBG_LOW(\"hash_page(ea=%016lx, access=%lx, trap=%lx\\n\",\n\t\tea, access, trap);\n\n\tif ((ea & ~REGION_MASK) >= PGTABLE_RANGE) {\n\t\tDBG_LOW(\" out of pgtable range !\\n\");\n \t\treturn 1;\n\t}\n\n\t/* Get region & vsid */\n \tswitch (REGION_ID(ea)) {\n\tcase USER_REGION_ID:\n\t\tuser_region = 1;\n\t\tmm = current->mm;\n\t\tif (! mm) {\n\t\t\tDBG_LOW(\" user region with no mm !\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tvsid = get_vsid(mm->context.id, ea);\n\t\tpsize = mm->context.user_psize;\n\t\tbreak;\n\tcase VMALLOC_REGION_ID:\n\t\tmm = &init_mm;\n\t\tvsid = get_kernel_vsid(ea);\n\t\tif (ea < VMALLOC_END)\n\t\t\tpsize = mmu_vmalloc_psize;\n\t\telse\n\t\t\tpsize = mmu_io_psize;\n\t\tbreak;\n\tdefault:\n\t\t/* Not a valid range\n\t\t * Send the problem up to do_page_fault \n\t\t */\n\t\treturn 1;\n\t}\n\tDBG_LOW(\" mm=%p, mm->pgdir=%p, vsid=%016lx\\n\", mm, mm->pgd, vsid);\n\n\t/* Get pgdir */\n\tpgdir = mm->pgd;\n\tif (pgdir == NULL)\n\t\treturn 1;\n\n\t/* Check CPU locality */\n\ttmp = cpumask_of_cpu(smp_processor_id());\n\tif (user_region && cpus_equal(mm->cpu_vm_mask, tmp))\n\t\tlocal = 1;\n\n\t/* Handle hugepage regions */\n\tif (unlikely(in_hugepage_area(mm->context, ea))) {\n\t\tDBG_LOW(\" -> huge page !\\n\");\n\t\treturn hash_huge_page(mm, access, ea, vsid, local, trap);\n\t}\n\n\t/* Get PTE and page size from page tables */\n\tptep = find_linux_pte(pgdir, ea);\n\tif (ptep == NULL || !pte_present(*ptep)) {\n\t\tDBG_LOW(\" no PTE !\\n\");\n\t\treturn 1;\n\t}\n\n#ifndef CONFIG_PPC_64K_PAGES\n\tDBG_LOW(\" i-pte: %016lx\\n\", pte_val(*ptep));\n#else\n\tDBG_LOW(\" i-pte: %016lx %016lx\\n\", pte_val(*ptep),\n\t\tpte_val(*(ptep + PTRS_PER_PTE)));\n#endif\n\t/* Pre-check access permissions (will be re-checked atomically\n\t * in __hash_page_XX but this pre-check is a fast path\n\t */\n\tif (access & ~pte_val(*ptep)) {\n\t\tDBG_LOW(\" no access !\\n\");\n\t\treturn 1;\n\t}\n\n\t/* Do actual hashing */\n#ifndef CONFIG_PPC_64K_PAGES\n\trc = __hash_page_4K(ea, access, vsid, ptep, trap, local);\n#else\n\tif (mmu_ci_restrictions) {\n\t\t/* If this PTE is non-cacheable, switch to 4k */\n\t\tif (psize == MMU_PAGE_64K &&\n\t\t    (pte_val(*ptep) & _PAGE_NO_CACHE)) {\n\t\t\tif (user_region) {\n\t\t\t\tpsize = MMU_PAGE_4K;\n\t\t\t\tmm->context.user_psize = MMU_PAGE_4K;\n\t\t\t\tmm->context.sllp = SLB_VSID_USER |\n\t\t\t\t\tmmu_psize_defs[MMU_PAGE_4K].sllp;\n\t\t\t} else if (ea < VMALLOC_END) {\n\t\t\t\t/*\n\t\t\t\t * some driver did a non-cacheable mapping\n\t\t\t\t * in vmalloc space, so switch vmalloc\n\t\t\t\t * to 4k pages\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ALERT \"Reducing vmalloc segment \"\n\t\t\t\t       \"to 4kB pages because of \"\n\t\t\t\t       \"non-cacheable mapping\\n\");\n\t\t\t\tpsize = mmu_vmalloc_psize = MMU_PAGE_4K;\n\t\t\t}\n#ifdef CONFIG_SPE_BASE\n\t\t\tspu_flush_all_slbs(mm);\n#endif\n\t\t}\n\t\tif (user_region) {\n\t\t\tif (psize != get_paca()->context.user_psize) {\n\t\t\t\tget_paca()->context = mm->context;\n\t\t\t\tslb_flush_and_rebolt();\n\t\t\t}\n\t\t} else if (get_paca()->vmalloc_sllp !=\n\t\t\t   mmu_psize_defs[mmu_vmalloc_psize].sllp) {\n\t\t\tget_paca()->vmalloc_sllp =\n\t\t\t\tmmu_psize_defs[mmu_vmalloc_psize].sllp;\n\t\t\tslb_flush_and_rebolt();\n\t\t}\n\t}\n\tif (psize == MMU_PAGE_64K)\n\t\trc = __hash_page_64K(ea, access, vsid, ptep, trap, local);\n\telse\n\t\trc = __hash_page_4K(ea, access, vsid, ptep, trap, local);\n#endif /* CONFIG_PPC_64K_PAGES */\n\n#ifndef CONFIG_PPC_64K_PAGES\n\tDBG_LOW(\" o-pte: %016lx\\n\", pte_val(*ptep));\n#else\n\tDBG_LOW(\" o-pte: %016lx %016lx\\n\", pte_val(*ptep),\n\t\tpte_val(*(ptep + PTRS_PER_PTE)));\n#endif\n\tDBG_LOW(\" -> rc=%d\\n\", rc);\n\treturn rc;\n}", "target": 1, "cwe": ["CWE-200"], "project": "linux-2.6", "commit_id": "721151d004dcf01a71b12bb6b893f9160284cf6e", "hash": 9811447350898023489441854944582708716, "size": 138, "message": "[POWERPC] Allow drivers to map individual 4k pages to userspace\n\nSome drivers have resources that they want to be able to map into\nuserspace that are 4k in size.  On a kernel configured with 64k pages\nwe currently end up mapping the 4k we want plus another 60k of\nphysical address space, which could contain anything.  This can\nintroduce security problems, for example in the case of an infiniband\nadaptor where the other 60k could contain registers that some other\nprogram is using for its communications.\n\nThis patch adds a new function, remap_4k_pfn, which drivers can use to\nmap a single 4k page to userspace regardless of whether the kernel is\nusing a 4k or a 64k page size.  Like remap_pfn_range, it would\ntypically be called in a driver's mmap function.  It only maps a\nsingle 4k page, which on a 64k page kernel appears replicated 16 times\nthroughout a 64k page.  On a 4k page kernel it reduces to a call to\nremap_pfn_range.\n\nThe way this works on a 64k kernel is that a new bit, _PAGE_4K_PFN,\ngets set on the linux PTE.  This alters the way that __hash_page_4K\ncomputes the real address to put in the HPTE.  The RPN field of the\nlinux PTE becomes the 4k RPN directly rather than being interpreted as\na 64k RPN.  Since the RPN field is 32 bits, this means that physical\naddresses being mapped with remap_4k_pfn have to be below 2^44,\ni.e. 0x100000000000.\n\nThe patch also factors out the code in arch/powerpc/mm/hash_utils_64.c\nthat deals with demoting a process to use 4k pages into one function\nthat gets called in the various different places where we need to do\nthat.  There were some discrepancies between exactly what was done in\nthe various places, such as a call to spu_flush_all_slbs in one case\nbut not in others.\n\nSigned-off-by: Paul Mackerras <paulus@samba.org>"}
{"func": "int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t struct ieee80211_rx_stats *rx_stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct ieee80211_hdr_4addr *hdr;\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tstruct net_device_stats *stats;\n\tunsigned int frag;\n\tu8 *payload;\n\tu16 ethertype;\n#ifdef NOT_YET\n\tstruct net_device *wds = NULL;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct net_device *wds = NULL;\n\tint frame_authorized = 0;\n\tint from_assoc_ap = 0;\n\tvoid *sta = NULL;\n#endif\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tstruct ieee80211_crypt_data *crypt = NULL;\n\tint keyidx = 0;\n\tint can_be_decrypted = 0;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tstats = &ieee->stats;\n\n\tif (skb->len < 10) {\n\t\tprintk(KERN_INFO \"%s: SKB length < 10\\n\", dev->name);\n\t\tgoto rx_dropped;\n\t}\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\thdrlen = ieee80211_get_hdrlen(fc);\n\n\t/* Put this code here so that we avoid duplicating it in all\n\t * Rx paths. - Jean II */\n#ifdef CONFIG_WIRELESS_EXT\n#ifdef IW_WIRELESS_SPY\t\t/* defined in iw_handler.h */\n\t/* If spy monitoring on */\n\tif (ieee->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\n\t\twstats.updated = 0;\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_RSSI) {\n\t\t\twstats.level = rx_stats->rssi;\n\t\t\twstats.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_LEVEL_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_NOISE) {\n\t\t\twstats.noise = rx_stats->noise;\n\t\t\twstats.updated |= IW_QUAL_NOISE_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_NOISE_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_SIGNAL) {\n\t\t\twstats.qual = rx_stats->signal;\n\t\t\twstats.updated |= IW_QUAL_QUAL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_QUAL_INVALID;\n\n\t\t/* Update spy records */\n\t\twireless_spy_update(ieee->dev, hdr->addr2, &wstats);\n\t}\n#endif\t\t\t\t/* IW_WIRELESS_SPY */\n#endif\t\t\t\t/* CONFIG_WIRELESS_EXT */\n\n#ifdef NOT_YET\n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n#endif\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += skb->len;\n\t\tieee80211_monitor_rx(ieee, skb, rx_stats);\n\t\treturn 1;\n\t}\n\n\tcan_be_decrypted = (is_multicast_ether_addr(hdr->addr1) ||\n\t\t\t    is_broadcast_ether_addr(hdr->addr2)) ?\n\t    ieee->host_mc_decrypt : ieee->host_decrypt;\n\n\tif (can_be_decrypted) {\n\t\tif (skb->len >= hdrlen + 3) {\n\t\t\t/* Top two-bits of byte 3 are the key index */\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\t\t}\n\n\t\t/* ieee->crypt[] is WEP_KEY (4) in length.  Given that keyidx\n\t\t * is only allowed 2-bits of storage, no value of keyidx can\n\t\t * be provided via above code that would result in keyidx\n\t\t * being out of range */\n\t\tcrypt = ieee->crypt[keyidx];\n\n#ifdef NOT_YET\n\t\tsta = NULL;\n\n\t\t/* Use station specific key to override default keys if the\n\t\t * receiver address is a unicast address (\"individual RA\"). If\n\t\t * bcrx_sta_key parameter is set, station specific key is used\n\t\t * even with broad/multicast targets (this is against IEEE\n\t\t * 802.11, but makes it easier to use different keys with\n\t\t * stations that do not support WEP key mapping). */\n\n\t\tif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\n\t\t\t(void)hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t       &sta);\n#endif\n\n\t\t/* allow NULL decrypt to indicate an station specific override\n\t\t * for default encryption */\n\t\tif (crypt && (crypt->ops == NULL ||\n\t\t\t      crypt->ops->decrypt_mpdu == NULL))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\n\t\t\t/* This seems to be triggered by some (multicast?)\n\t\t\t * frames from other than current BSS, so just drop the\n\t\t\t * frames silently instead of filling system log with\n\t\t\t * these reports. */\n\t\t\tIEEE80211_DEBUG_DROP(\"Decryption failed (not set)\"\n\t\t\t\t\t     \" (SA=\" MAC_FMT \")\\n\",\n\t\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#ifdef NOT_YET\n\tif (type != WLAN_FC_TYPE_DATA) {\n\t\tif (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&\n\t\t    fc & IEEE80211_FCTL_PROTECTED && ieee->host_decrypt &&\n\t\t    (keyidx = hostap_rx_frame_decrypt(ieee, skb, crypt)) < 0) {\n\t\t\tprintk(KERN_DEBUG \"%s: failed to decrypt mgmt::auth \"\n\t\t\t       \"from \" MAC_FMT \"\\n\", dev->name,\n\t\t\t       MAC_ARG(hdr->addr2));\n\t\t\t/* TODO: could inform hostapd about this so that it\n\t\t\t * could send auth failure report */\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n#endif\n\t/* drop duplicate 802.11 retransmissions (IEEE 802.11 Chap. 9.29) */\n\tif (sc == ieee->prev_seq_ctl)\n\t\tgoto rx_dropped;\n\telse\n\t\tieee->prev_seq_ctl = sc;\n\n\t/* Data frame - extract src/dst addresses */\n\tif (skb->len < IEEE80211_3ADDR_LEN)\n\t\tgoto rx_dropped;\n\n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < IEEE80211_4ADDR_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tbreak;\n\tcase 0:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\t}\n\n#ifdef NOT_YET\n\tif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds) {\n\t\tskb->dev = dev = wds;\n\t\tstats = hostap_get_stats(dev);\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_FROMDS && ieee->stadev\n\t    && !compare_ether_addr(hdr->addr2, ieee->assoc_ap_addr)) {\n\t\t/* Frame from BSSID of the AP for which we are a client */\n\t\tskb->dev = dev = ieee->stadev;\n\t\tstats = hostap_get_stats(dev);\n\t\tfrom_assoc_ap = 1;\n\t}\n#endif\n\n\tdev->last_rx = jiffies;\n\n#ifdef NOT_YET\n\tif ((ieee->iw_mode == IW_MODE_MASTER ||\n\t     ieee->iw_mode == IW_MODE_REPEAT) && !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\n\t\t\t\t\t     wds != NULL)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\t\tframe_authorized = 0;\n\t\t\tbreak;\n\t\tcase AP_RX_CONTINUE:\n\t\t\tframe_authorized = 1;\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n#endif\n\n\t/* Nullfunc frames may have PS-bit set, so they must be passed to\n\t * hostap_handle_sta_rx() before being dropped here. */\n\n\tstype &= ~IEEE80211_STYPE_QOS_DATA;\n\n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tIEEE80211_DEBUG_DROP(\"RX: dropped data frame \"\n\t\t\t\t\t     \"with no data (type=0x%02x, \"\n\t\t\t\t\t     \"subtype=0x%02x, len=%d)\\n\",\n\t\t\t\t\t     type, stype, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possibly fragmented, possibly encrypted) payload */\n\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    (keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\n\t/* skb: hdr + (possibly fragmented) plaintext payload */\n\t// PR: FIXME: hostap has additional conditions in the \"if\" below:\n\t// ieee->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\n\tif ((frag != 0) || (fc & IEEE80211_FCTL_MOREFRAGS)) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\n\t\tIEEE80211_DEBUG_FRAG(\"Rx Fragment received (%u)\\n\", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\n\t\t\t\t\t\"Rx cannot get skb from fragment \"\n\t\t\t\t\t\"cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t\t\t(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t\t\tWLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tprintk(KERN_WARNING \"%s: host decrypted and \"\n\t\t\t       \"reassembled frame did not fit skb\\n\",\n\t\t\t       dev->name);\n\t\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t/* copy first fragment (including full headers) into\n\t\t\t * beginning of the fragment cache skb */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(frag_skb, flen), flen);\n\t\t} else {\n\t\t\t/* append frame payload to the end of the fragment\n\t\t\t * cache skb */\n\t\t\tskb_copy_from_linear_data_offset(skb, hdrlen,\n\t\t\t\t      skb_put(frag_skb, flen), flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t/* more fragments expected - leave the skb in fragment\n\t\t\t * cache for now; it will be delivered to upper layers\n\t\t\t * after all fragments have been received */\n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t/* this was the last fragment and the frame will be\n\t\t * delivered, so remove skb from fragment cache */\n\t\tskb = frag_skb;\n\t\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t/* skb: hdr + (possible reassembled) full MSDU payload; possibly still\n\t * encrypted/authenticated */\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    ieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep) {\n\t\tif (\t\t/*ieee->ieee802_1x && */\n\t\t\t   ieee80211_is_eapol_frame(ieee, skb)) {\n\t\t\t/* pass unencrypted EAPOL frames even if encryption is\n\t\t\t * configured */\n\t\t} else {\n\t\t\tIEEE80211_DEBUG_DROP(\"encryption configured, but RX \"\n\t\t\t\t\t     \"frame not encrypted (SA=\" MAC_FMT\n\t\t\t\t\t     \")\\n\", MAC_ARG(hdr->addr2));\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep &&\n\t    !ieee80211_is_eapol_frame(ieee, skb)) {\n\t\tIEEE80211_DEBUG_DROP(\"dropped unencrypted RX data \"\n\t\t\t\t     \"frame from \" MAC_FMT\n\t\t\t\t     \" (drop_unencrypted=1)\\n\",\n\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\tgoto rx_dropped;\n\t}\n\n\t/* If the frame was decrypted in hardware, we may need to strip off\n\t * any security data (IV, ICV, etc) that was left behind */\n\tif (!can_be_decrypted && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    ieee->host_strip_iv_icv) {\n\t\tint trimlen = 0;\n\n\t\t/* Top two-bits of byte 3 are the key index */\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\n\t\t/* To strip off any security data which appears before the\n\t\t * payload, we simply increase hdrlen (as the header gets\n\t\t * chopped off immediately below). For the security data which\n\t\t * appears after the payload, we use skb_trim. */\n\n\t\tswitch (ieee->sec.encode_alg[keyidx]) {\n\t\tcase SEC_ALG_WEP:\n\t\t\t/* 4 byte IV */\n\t\t\thdrlen += 4;\n\t\t\t/* 4 byte ICV */\n\t\t\ttrimlen = 4;\n\t\t\tbreak;\n\t\tcase SEC_ALG_TKIP:\n\t\t\t/* 4 byte IV, 4 byte ExtIV */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC, 4 byte ICV */\n\t\t\ttrimlen = 12;\n\t\t\tbreak;\n\t\tcase SEC_ALG_CCMP:\n\t\t\t/* 8 byte CCMP header */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC */\n\t\t\ttrimlen = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len < trimlen)\n\t\t\tgoto rx_dropped;\n\n\t\t__skb_trim(skb, skb->len - trimlen);\n\n\t\tif (skb->len < hdrlen)\n\t\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possible reassembled) full plaintext payload */\n\n\tpayload = skb->data + hdrlen;\n\tethertype = (payload[6] << 8) | payload[7];\n\n#ifdef NOT_YET\n\t/* If IEEE 802.1X is used, check whether the port is authorized to send\n\t * the received frame. */\n\tif (ieee->ieee802_1x && ieee->iw_mode == IW_MODE_MASTER) {\n\t\tif (ethertype == ETH_P_PAE) {\n\t\t\tprintk(KERN_DEBUG \"%s: RX: IEEE 802.1X frame\\n\",\n\t\t\t       dev->name);\n\t\t\tif (ieee->hostapd && ieee->apdev) {\n\t\t\t\t/* Send IEEE 802.1X frames to the user\n\t\t\t\t * space daemon for processing */\n\t\t\t\tprism2_rx_80211(ieee->apdev, skb, rx_stats,\n\t\t\t\t\t\tPRISM2_RX_MGMT);\n\t\t\t\tieee->apdevstats.rx_packets++;\n\t\t\t\tieee->apdevstats.rx_bytes += skb->len;\n\t\t\t\tgoto rx_exit;\n\t\t\t}\n\t\t} else if (!frame_authorized) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped frame from \"\n\t\t\t       \"unauthorized port (IEEE 802.1X): \"\n\t\t\t       \"ethertype=0x%04x\\n\", dev->name, ethertype);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#endif\n\n\t/* convert hdr + possible LLC headers into Ethernet header */\n\tif (skb->len - hdrlen >= 8 &&\n\t    ((memcmp(payload, rfc1042_header, SNAP_SIZE) == 0 &&\n\t      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\n\t     memcmp(payload, bridge_tunnel_header, SNAP_SIZE) == 0)) {\n\t\t/* remove RFC1042 or Bridge-Tunnel encapsulation and\n\t\t * replace EtherType */\n\t\tskb_pull(skb, hdrlen + SNAP_SIZE);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t} else {\n\t\tu16 len;\n\t\t/* Leave Ethernet header part of hdr and full payload */\n\t\tskb_pull(skb, hdrlen);\n\t\tlen = htons(skb->len);\n\t\tmemcpy(skb_push(skb, 2), &len, 2);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t}\n\n#ifdef NOT_YET\n\tif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t    IEEE80211_FCTL_TODS) && skb->len >= ETH_HLEN + ETH_ALEN) {\n\t\t/* Non-standard frame: get addr4 from its bogus location after\n\t\t * the payload */\n\t\tskb_copy_to_linear_data_offset(skb, ETH_ALEN,\n\t\t\t\t\t       skb->data + skb->len - ETH_ALEN,\n\t\t\t\t\t       ETH_ALEN);\n\t\tskb_trim(skb, skb->len - ETH_ALEN);\n\t}\n#endif\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len;\n\n#ifdef NOT_YET\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds && ieee->ap->bridge_packets) {\n\t\tif (dst[0] & 0x01) {\n\t\t\t/* copy multicast frame both to the higher layers and\n\t\t\t * to the wireless media */\n\t\t\tieee->ap->bridged_multicast++;\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tprintk(KERN_DEBUG \"%s: skb_clone failed for \"\n\t\t\t\t       \"multicast frame\\n\", dev->name);\n\t\t} else if (hostap_is_sta_assoc(ieee->ap, dst)) {\n\t\t\t/* send frame directly to the associated STA using\n\t\t\t * wireless media and not passing to higher layers */\n\t\t\tieee->ap->bridged_unicast++;\n\t\t\tskb2 = skb;\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tif (skb2 != NULL) {\n\t\t/* send to wireless media */\n\t\tskb2->dev = dev;\n\t\tskb2->protocol = __constant_htons(ETH_P_802_3);\n\t\tskb_reset_mac_header(skb2);\n\t\tskb_reset_network_header(skb2);\n\t\t/* skb2->network_header += ETH_HLEN; */\n\t\tdev_queue_xmit(skb2);\n\t}\n#endif\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tskb->ip_summed = CHECKSUM_NONE;\t/* 802.11 crc not sufficient */\n\t\tif (netif_rx(skb) == NET_RX_DROP) {\n\t\t\t/* netif_rx always succeeds, but it might drop\n\t\t\t * the packet.  If it drops the packet, we log that\n\t\t\t * in our stats. */\n\t\t\tIEEE80211_DEBUG_DROP\n\t\t\t    (\"RX: netif_rx dropped the packet\\n\");\n\t\t\tstats->rx_dropped++;\n\t\t}\n\t}\n\n      rx_exit:\n#ifdef NOT_YET\n\tif (sta)\n\t\thostap_handle_sta_release(sta);\n#endif\n\treturn 1;\n\n      rx_dropped:\n\tstats->rx_dropped++;\n\n\t/* Returning 0 indicates to caller that we have not handled the SKB--\n\t * so it is still allocated and can be used again by underlying\n\t * hardware as a DMA target */\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-189"], "project": "linux-2.6", "commit_id": "04045f98e0457aba7d4e6736f37eed189c48a5f7", "hash": 308579844544821127492397604808934650173, "size": 502, "message": "[IEEE80211]: avoid integer underflow for runt rx frames\n\nReported by Chris Evans <scarybeasts@gmail.com>:\n\n> The summary is that an evil 80211 frame can crash out a victim's\n> machine. It only applies to drivers using the 80211 wireless code, and\n> only then to certain drivers (and even then depends on a card's\n> firmware not dropping a dubious packet). I must confess I'm not\n> keeping track of Linux wireless support, and the different protocol\n> stacks etc.\n>\n> Details are as follows:\n>\n> ieee80211_rx() does not explicitly check that \"skb->len >= hdrlen\".\n> There are other skb->len checks, but not enough to prevent a subtle\n> off-by-two error if the frame has the IEEE80211_STYPE_QOS_DATA flag\n> set.\n>\n> This leads to integer underflow and crash here:\n>\n> if (frag != 0)\n>    flen -= hdrlen;\n>\n> (flen is subsequently used as a memcpy length parameter).\n\nHow about this?\n\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int do_dccp_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct dccp_sock *dp;\n\tint val, len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tdp = dccp_sk(sk);\n\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_PACKET_SIZE:\n\t\tDCCP_WARN(\"sockopt(PACKET_SIZE) is deprecated: fix your app\\n\");\n\t\treturn 0;\n\tcase DCCP_SOCKOPT_SERVICE:\n\t\treturn dccp_getsockopt_service(sk, len,\n\t\t\t\t\t       (__be32 __user *)optval, optlen);\n\tcase DCCP_SOCKOPT_SEND_CSCOV:\n\t\tval = dp->dccps_pcslen;\n\t\tbreak;\n\tcase DCCP_SOCKOPT_RECV_CSCOV:\n\t\tval = dp->dccps_pcrlen;\n\t\tbreak;\n\tcase 128 ... 191:\n\t\treturn ccid_hc_rx_getsockopt(dp->dccps_hc_rx_ccid, sk, optname,\n\t\t\t\t\t     len, (u32 __user *)optval, optlen);\n\tcase 192 ... 255:\n\t\treturn ccid_hc_tx_getsockopt(dp->dccps_hc_tx_ccid, sk, optname,\n\t\t\t\t\t     len, (u32 __user *)optval, optlen);\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "39ebc0276bada8bb70e067cb6d0eb71839c0fb08", "hash": 329364480182313507598951454775228741886, "size": 42, "message": "[DCCP] getsockopt: Fix DCCP_SOCKOPT_[SEND,RECV]_CSCOV\n\nWe were only checking if there was enough space to put the int, but\nleft len as specified by the (malicious) user, sigh, fix it by setting\nlen to sizeof(val) and transfering just one int worth of data, the one\nasked for.\n\nAlso check for negative len values.\n\nSigned-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tcompparms->stepsizes = jas_alloc2(compparms->numstepsizes,\n\t\t  sizeof(uint_fast16_t));\n\t\tassert(compparms->stepsizes);\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1, "cwe": [], "project": "jasper", "commit_id": "4031ca321d8cb5798c316ab39c7a5dc88a61fdd7", "hash": 254403990052538507929301018495167224098, "size": 54, "message": "Incorporated changes from patch\njasper-1.900.3-libjasper-stepsizes-overflow.patch"}
{"func": "isdn_net_setcfg(isdn_net_ioctl_cfg * cfg)\n{\n\tisdn_net_dev *p = isdn_net_findif(cfg->name);\n\tulong features;\n\tint i;\n\tint drvidx;\n\tint chidx;\n\tchar drvid[25];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* See if any registered driver supports the features we want */\n\t\tfeatures = ((1 << cfg->l2_proto) << ISDN_FEATURE_L2_SHIFT) |\n\t\t\t((1 << cfg->l3_proto) << ISDN_FEATURE_L3_SHIFT);\n\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\tif (dev->drv[i])\n\t\t\t\tif ((dev->drv[i]->interface->features & features) == features)\n\t\t\t\t\tbreak;\n\t\tif (i == ISDN_MAX_DRIVERS) {\n\t\t\tprintk(KERN_WARNING \"isdn_net: No driver with selected features\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (lp->p_encap != cfg->p_encap){\n#ifdef CONFIG_ISDN_X25\n\t\t\tstruct concap_proto * cprot = p -> cprot;\n#endif\n\t\t\tif (isdn_net_device_started(p)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: cannot change encap when if is up\\n\",\n\t\t\t\t       p->dev->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n#ifdef CONFIG_ISDN_X25\n\t\t\tif( cprot && cprot -> pops )\n\t\t\t\tcprot -> pops -> proto_del ( cprot );\n\t\t\tp -> cprot = NULL;\n\t\t\tlp -> dops = NULL;\n\t\t\t/* ... ,  prepare for configuration of new one ... */\n\t\t\tswitch ( cfg -> p_encap ){\n\t\t\tcase ISDN_NET_ENCAP_X25IFACE:\n\t\t\t\tlp -> dops = &isdn_concap_reliable_dl_dops;\n\t\t\t}\n\t\t\t/* ... and allocate new one ... */\n\t\t\tp -> cprot = isdn_concap_new( cfg -> p_encap );\n\t\t\t/* p -> cprot == NULL now if p_encap is not supported\n\t\t\t   by means of the concap_proto mechanism */\n\t\t\t/* the protocol is not configured yet; this will\n\t\t\t   happen later when isdn_net_reset() is called */\n#endif\n\t\t}\n\t\tswitch ( cfg->p_encap ) {\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n#ifndef CONFIG_ISDN_PPP\n\t\t\tprintk(KERN_WARNING \"%s: SyncPPP support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_PPP;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n\t\t\tp->dev->do_ioctl = isdn_ppp_dev_ioctl;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_X25IFACE:\n#ifndef CONFIG_ISDN_X25\n\t\t\tprintk(KERN_WARNING \"%s: isdn-x25 support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_X25;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tp->dev->do_ioctl = isdn_ciscohdlck_dev_ioctl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif( cfg->p_encap >= 0 &&\n\t\t\t    cfg->p_encap <= ISDN_NET_ENCAP_MAX_ENCAP )\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: encapsulation protocol %d not supported\\n\",\n\t\t\t       p->dev->name, cfg->p_encap);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strlen(cfg->drvid)) {\n\t\t\t/* A bind has been requested ... */\n\t\t\tchar *c,\n\t\t\t*e;\n\n\t\t\tdrvidx = -1;\n\t\t\tchidx = -1;\n\t\t\tstrcpy(drvid, cfg->drvid);\n\t\t\tif ((c = strchr(drvid, ','))) {\n\t\t\t\t/* The channel-number is appended to the driver-Id with a comma */\n\t\t\t\tchidx = (int) simple_strtoul(c + 1, &e, 10);\n\t\t\t\tif (e == c)\n\t\t\t\t\tchidx = -1;\n\t\t\t\t*c = '\\0';\n\t\t\t}\n\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t/* Lookup driver-Id in array */\n\t\t\t\tif (!(strcmp(dev->drvid[i], drvid))) {\n\t\t\t\t\tdrvidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif ((drvidx == -1) || (chidx == -1))\n\t\t\t\t/* Either driver-Id or channel-number invalid */\n\t\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\t/* Parameters are valid, so get them */\n\t\t\tdrvidx = lp->pre_device;\n\t\t\tchidx = lp->pre_channel;\n\t\t}\n\t\tif (cfg->exclusive > 0) {\n\t\t\tunsigned long flags;\n\n\t\t\t/* If binding is exclusive, try to grab the channel */\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((i = isdn_get_free_channel(ISDN_USAGE_NET,\n\t\t\t\tlp->l2_proto, lp->l3_proto, drvidx,\n\t\t\t\tchidx, lp->msn)) < 0) {\n\t\t\t\t/* Grab failed, because desired channel is in use */\n\t\t\t\tlp->exclusive = -1;\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\t/* All went ok, so update isdninfo */\n\t\t\tdev->usage[i] = ISDN_USAGE_EXCLUSIVE;\n\t\t\tisdn_info_update();\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tlp->exclusive = i;\n\t\t} else {\n\t\t\t/* Non-exclusive binding or unbind. */\n\t\t\tlp->exclusive = -1;\n\t\t\tif ((lp->pre_device != -1) && (cfg->exclusive == -1)) {\n\t\t\t\tisdn_unexclusive_channel(lp->pre_device, lp->pre_channel);\n\t\t\t\tisdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);\n\t\t\t\tdrvidx = -1;\n\t\t\t\tchidx = -1;\n\t\t\t}\n\t\t}\n\t\tstrcpy(lp->msn, cfg->eaz);\n\t\tlp->pre_device = drvidx;\n\t\tlp->pre_channel = chidx;\n\t\tlp->onhtime = cfg->onhtime;\n\t\tlp->charge = cfg->charge;\n\t\tlp->l2_proto = cfg->l2_proto;\n\t\tlp->l3_proto = cfg->l3_proto;\n\t\tlp->cbdelay = cfg->cbdelay;\n\t\tlp->dialmax = cfg->dialmax;\n\t\tlp->triggercps = cfg->triggercps;\n\t\tlp->slavedelay = cfg->slavedelay * HZ;\n\t\tlp->pppbind = cfg->pppbind;\n\t\tlp->dialtimeout = cfg->dialtimeout >= 0 ? cfg->dialtimeout * HZ : -1;\n\t\tlp->dialwait = cfg->dialwait * HZ;\n\t\tif (cfg->secure)\n\t\t\tlp->flags |= ISDN_NET_SECURE;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_SECURE;\n\t\tif (cfg->cbhup)\n\t\t\tlp->flags |= ISDN_NET_CBHUP;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_CBHUP;\n\t\tswitch (cfg->callback) {\n\t\t\tcase 0:\n\t\t\t\tlp->flags &= ~(ISDN_NET_CALLBACK | ISDN_NET_CBOUT);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlp->flags |= ISDN_NET_CALLBACK;\n\t\t\t\tlp->flags &= ~ISDN_NET_CBOUT;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlp->flags |= ISDN_NET_CBOUT;\n\t\t\t\tlp->flags &= ~ISDN_NET_CALLBACK;\n\t\t\t\tbreak;\n\t\t}\n\t\tlp->flags &= ~ISDN_NET_DIALMODE_MASK;\t/* first all bits off */\n\t\tif (cfg->dialmode && !(cfg->dialmode & ISDN_NET_DIALMODE_MASK)) {\n\t\t\t/* old isdnctrl version, where only 0 or 1 is given */\n\t\t\tprintk(KERN_WARNING\n\t\t\t     \"Old isdnctrl version detected! Please update.\\n\");\n\t\t\tlp->flags |= ISDN_NET_DM_OFF; /* turn on `off' bit */\n\t\t}\n\t\telse {\n\t\t\tlp->flags |= cfg->dialmode;  /* turn on selected bits */\n\t\t}\n\t\tif (cfg->chargehup)\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_CHARGEHUP;\n\t\tif (cfg->ihup)\n\t\t\tlp->hupflags |= ISDN_INHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_INHUP;\n\t\tif (cfg->chargeint > 10) {\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE;\n\t\t\tlp->chargeint = cfg->chargeint * HZ;\n\t\t}\n\t\tif (cfg->p_encap != lp->p_encap) {\n\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_RAWIP) {\n\t\t\t\tp->dev->header_ops = NULL;\n\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t} else {\n\t\t\t\tp->dev->header_ops = &isdn_header_ops;\n\t\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\t\t\t\tp->dev->flags = IFF_BROADCAST | IFF_MULTICAST;\n\t\t\t\telse\n\t\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t}\n\t\t}\n\t\tlp->p_encap = cfg->p_encap;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "0f13864e5b24d9cbe18d125d41bfa4b726a82e40", "hash": 80796293720356790057810511838637183896, "size": 215, "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "isdn_net_addphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tisdn_net_phone *n;\n\n\tif (p) {\n\t\tif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(n->num, phone->phone);\n\t\tn->next = p->local->phone[phone->outgoing & 1];\n\t\tp->local->phone[phone->outgoing & 1] = n;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "0f13864e5b24d9cbe18d125d41bfa4b726a82e40", "hash": 242762251649869568016628227707027738238, "size": 15, "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "isdn_net_find_icall(int di, int ch, int idx, setup_parm *setup)\n{\n\tchar *eaz;\n\tint si1;\n\tint si2;\n\tint ematch;\n\tint wret;\n\tint swapped;\n\tint sidx = 0;\n\tu_long flags;\n\tisdn_net_dev *p;\n\tisdn_net_phone *n;\n\tchar nr[32];\n\tchar *my_eaz;\n\n\t/* Search name in netdev-chain */\n\tif (!setup->phone[0]) {\n\t\tnr[0] = '0';\n\t\tnr[1] = '\\0';\n\t\tprintk(KERN_INFO \"isdn_net: Incoming call without OAD, assuming '0'\\n\");\n\t} else\n\t\tstrcpy(nr, setup->phone);\n\tsi1 = (int) setup->si1;\n\tsi2 = (int) setup->si2;\n\tif (!setup->eazmsn[0]) {\n\t\tprintk(KERN_WARNING \"isdn_net: Incoming call without CPN, assuming '0'\\n\");\n\t\teaz = \"0\";\n\t} else\n\t\teaz = setup->eazmsn;\n\tif (dev->net_verbose > 1)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s,%d,%d -> %s\\n\", nr, si1, si2, eaz);\n\t/* Accept DATA and VOICE calls at this stage\n\t * local eaz is checked later for allowed call types\n\t */\n\tif ((si1 != 7) && (si1 != 1)) {\n\t\tif (dev->net_verbose > 1)\n\t\t\tprintk(KERN_INFO \"isdn_net: Service-Indicator not 1 or 7, ignored\\n\");\n\t\treturn 0;\n\t}\n\tn = (isdn_net_phone *) 0;\n\tp = dev->netdev;\n\tematch = wret = swapped = 0;\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: di=%d ch=%d idx=%d usg=%d\\n\", di, ch, idx,\n\t\tdev->usage[idx]);\n#endif\n\twhile (p) {\n\t\tint matchret;\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* If last check has triggered as binding-swap, revert it */\n\t\tswitch (swapped) {\n\t\t\tcase 2:\n\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t/* fall through */\n\t\t\tcase 1:\n\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\tbreak;\n\t\t}\n\t\tswapped = 0;\n                /* check acceptable call types for DOV */\n                my_eaz = isdn_map_eaz2msn(lp->msn, di);\n                if (si1 == 1) { /* it's a DOV call, check if we allow it */\n                        if (*my_eaz == 'v' || *my_eaz == 'V' ||\n\t\t\t    *my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                        else\n                                my_eaz = NULL; /* force non match */\n                } else { /* it's a DATA call, check if we allow it */\n                        if (*my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                }\n                if (my_eaz)\n                        matchret = isdn_msncmp(eaz, my_eaz);\n                else\n                        matchret = 1;\n                if (!matchret)\n                        ematch = 1;\n\n\t\t/* Remember if more numbers eventually can match */\n\t\tif (matchret > wret)\n\t\t\twret = matchret;\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\tprintk(KERN_DEBUG \"n_fi: if='%s', l.msn=%s, l.flags=%d, l.dstate=%d\\n\",\n\t\t       p->dev->name, lp->msn, lp->flags, lp->dialstate);\n#endif\n\t\tif ((!matchret) &&                                        /* EAZ is matching   */\n\t\t    (((!(lp->flags & ISDN_NET_CONNECTED)) &&              /* but not connected */\n\t\t      (USG_NONE(dev->usage[idx]))) ||                     /* and ch. unused or */\n\t\t     ((((lp->dialstate == 4) || (lp->dialstate == 12)) && /* if dialing        */\n\t\t       (!(lp->flags & ISDN_NET_CALLBACK)))                /* but no callback   */\n\t\t     )))\n\t\t\t {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match1, pdev=%d pch=%d\\n\",\n\t\t\t       lp->pre_device, lp->pre_channel);\n#endif\n\t\t\tif (dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) {\n\t\t\t\tif ((lp->pre_channel != ch) ||\n\t\t\t\t    (lp->pre_device != di)) {\n\t\t\t\t\t/* Here we got a problem:\n\t\t\t\t\t * If using an ICN-Card, an incoming call is always signaled on\n\t\t\t\t\t * on the first channel of the card, if both channels are\n\t\t\t\t\t * down. However this channel may be bound exclusive. If the\n\t\t\t\t\t * second channel is free, this call should be accepted.\n\t\t\t\t\t * The solution is horribly but it runs, so what:\n\t\t\t\t\t * We exchange the exclusive bindings of the two channels, the\n\t\t\t\t\t * corresponding variables in the interface-structs.\n\t\t\t\t\t */\n\t\t\t\t\tif (ch == 0) {\n\t\t\t\t\t\tsidx = isdn_dc2minor(di, 1);\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: ch is 0\\n\");\n#endif\n\t\t\t\t\t\tif (USG_NONE(dev->usage[sidx])) {\n\t\t\t\t\t\t\t/* Second Channel is free, now see if it is bound\n\t\t\t\t\t\t\t * exclusive too. */\n\t\t\t\t\t\t\tif (dev->usage[sidx] & ISDN_USAGE_EXCLUSIVE) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and bound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* Yes, swap bindings only, if the original\n\t\t\t\t\t\t\t\t * binding is bound to channel 1 of this driver */\n\t\t\t\t\t\t\t\tif ((lp->pre_device == di) &&\n\t\t\t\t\t\t\t\t    (lp->pre_channel == 1)) {\n\t\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\t\tswapped = 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t/* ... else iterate next device */\n\t\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and unbound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* No, swap always and swap excl-usage also */\n\t\t\t\t\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\tswapped = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Now check for exclusive binding again */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check\\n\");\n#endif\n\t\t\t\t\t\t\tif ((dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) &&\n\t\t\t\t\t\t\t    ((lp->pre_channel != ch) ||\n\t\t\t\t\t\t\t     (lp->pre_device != di))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check failed\\n\");\n#endif\n\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* We are already on the second channel, so nothing to do */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: already on 2nd channel\\n\");\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match2\\n\");\n#endif\n\t\t\tn = lp->phone[0];\n\t\t\tif (lp->flags & ISDN_NET_SECURE) {\n\t\t\t\twhile (n) {\n\t\t\t\t\tif (!isdn_msncmp(nr, n->num))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tn = (isdn_net_phone *) n->next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n || (!(lp->flags & ISDN_NET_SECURE))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\tprintk(KERN_DEBUG \"n_fi: match3\\n\");\n#endif\n\t\t\t\t/* matching interface found */\n\n\t\t\t\t/*\n\t\t\t\t * Is the state STOPPED?\n\t\t\t\t * If so, no dialin is allowed,\n\t\t\t\t * so reject actively.\n\t\t\t\t * */\n\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\tprintk(KERN_INFO \"incoming call, interface %s `stopped' -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Is the interface up?\n\t\t\t\t * If not, reject the call actively.\n\t\t\t\t */\n\t\t\t\tif (!isdn_net_device_started(p)) {\n\t\t\t\t\tprintk(KERN_INFO \"%s: incoming call, interface down -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/* Interface is up, now see if it's a slave. If so, see if\n\t\t\t\t * it's master and parent slave is online. If not, reject the call.\n\t\t\t\t */\n\t\t\t\tif (lp->master) {\n\t\t\t\t\tisdn_net_local *mlp = (isdn_net_local *) lp->master->priv;\n\t\t\t\t\tprintk(KERN_DEBUG \"ICALLslv: %s\\n\", p->dev->name);\n\t\t\t\t\tprintk(KERN_DEBUG \"master=%s\\n\", lp->master->name);\n\t\t\t\t\tif (mlp->flags & ISDN_NET_CONNECTED) {\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master online\\n\");\n\t\t\t\t\t\t/* Master is online, find parent-slave (master if first slave) */\n\t\t\t\t\t\twhile (mlp->slave) {\n\t\t\t\t\t\t\tif ((isdn_net_local *) mlp->slave->priv == lp)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tmlp = (isdn_net_local *) mlp->slave->priv;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master offline\\n\");\n\t\t\t\t\t/* Found parent, if it's offline iterate next device */\n\t\t\t\t\tprintk(KERN_DEBUG \"mlpf: %d\\n\", mlp->flags & ISDN_NET_CONNECTED);\n\t\t\t\t\tif (!(mlp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif (lp->flags & ISDN_NET_CALLBACK) {\n\t\t\t\t\tint chi;\n\t\t\t\t\t/*\n\t\t\t\t\t * Is the state MANUAL?\n\t\t\t\t\t * If so, no callback can be made,\n\t\t\t\t\t * so reject actively.\n\t\t\t\t\t * */\n\t\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\t\tprintk(KERN_INFO \"incoming call for callback, interface %s `off' -> rejected\\n\",\n\t\t\t\t\t\t       p->dev->name);\n\t\t\t\t\t\treturn 3;\n\t\t\t\t\t}\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s, start callback\\n\",\n\t\t\t\t\t       p->dev->name, nr, eaz);\n\t\t\t\t\tif (lp->phone[1]) {\n\t\t\t\t\t\t/* Grab a free ISDN-Channel */\n\t\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\t\tif ((chi = \n\t\t\t\t\t\t\tisdn_get_free_channel(\n\t\t\t\t\t\t\t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\t  \tlp->pre_device,\n\t\t\t\t\t\t \t\tlp->pre_channel,\n\t\t\t\t\t\t \t\tlp->msn)\n\t\t\t\t\t\t\t\t) < 0) {\n\n\t\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net_find_icall: No channel for %s\\n\",\n\t\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Setup dialstate. */\n\t\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\t\tlp->dialstate = 11;\n\t\t\t\t\t\t/* Connect interface with channel */\n\t\t\t\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t/* Initiate dialing by returning 2 or 4 */\n\t\t\t\t\t\treturn (lp->flags & ISDN_NET_CBHUP) ? 2 : 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net: %s: No phone number\\n\",\n\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s accepted\\n\",\n\t\t\t\t\t\tp->dev->name, nr, eaz);\n\t\t\t\t\t/* if this interface is dialing, it does it probably on a different\n\t\t\t\t\t   device, so free this device */\n\t\t\t\t\tif ((lp->dialstate == 4) || (lp->dialstate == 12)) {\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_ppp_free(lp);\n#endif\n\t\t\t\t\t\tisdn_net_lp_disconnected(lp);\n\t\t\t\t\t\tisdn_free_channel(lp->isdn_device, lp->isdn_channel,\n\t\t\t\t\t\t\t ISDN_USAGE_NET);\n\t\t\t\t\t}\n\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\tdev->usage[idx] &= ISDN_USAGE_EXCLUSIVE;\n\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_NET;\n\t\t\t\t\tstrcpy(dev->num[idx], nr);\n\t\t\t\t\tisdn_info_update();\n\t\t\t\t\tdev->st_netdev[idx] = lp->netdev;\n\t\t\t\t\tlp->isdn_device = di;\n\t\t\t\t\tlp->isdn_channel = ch;\n\t\t\t\t\tlp->ppp_slot = -1;\n\t\t\t\t\tlp->flags |= ISDN_NET_CONNECTED;\n\t\t\t\t\tlp->dialstate = 7;\n\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\tlp->outgoing = 0;\n\t\t\t\t\tlp->huptimer = 0;\n\t\t\t\t\tlp->hupflags |= ISDN_WAITCHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_HAVECHARGE;\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\t/* If none of configured EAZ/MSN matched and not verbose, be silent */\n\tif (!ematch || dev->net_verbose)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s -> %d %s ignored\\n\", nr, di, eaz);\n\treturn (wret == 2)?5:0;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "0f13864e5b24d9cbe18d125d41bfa4b726a82e40", "hash": 322344461636009915251514953321701663520, "size": 326, "message": "isdn: avoid copying overly-long strings\n\nAddresses http://bugzilla.kernel.org/show_bug.cgi?id=9416\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int esp6_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ip_esp_hdr *esph;\n\tstruct esp_data *esp = x->data;\n\tstruct crypto_aead *aead = esp->aead;\n\tstruct aead_request *req;\n\tstruct sk_buff *trailer;\n\tint elen = skb->len - sizeof(*esph) - crypto_aead_ivsize(aead);\n\tint nfrags;\n\tint ret = 0;\n\tvoid *tmp;\n\tu8 *iv;\n\tstruct scatterlist *sg;\n\tstruct scatterlist *asg;\n\n\tif (!pskb_may_pull(skb, sizeof(*esph))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (elen <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((nfrags = skb_cow_data(skb, 0, &trailer)) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\ttmp = esp_alloc_tmp(aead, nfrags + 1);\n\tif (!tmp)\n\t\tgoto out;\n\n\tESP_SKB_CB(skb)->tmp = tmp;\n\tiv = esp_tmp_iv(aead, tmp);\n\treq = esp_tmp_req(aead, iv);\n\tasg = esp_req_sg(aead, req);\n\tsg = asg + 1;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tesph = (struct ip_esp_hdr *)skb->data;\n\n\t/* Get ivec. This can be wrong, check against another impls. */\n\tiv = esph->enc_data;\n\n\tsg_init_table(sg, nfrags);\n\tskb_to_sgvec(skb, sg, sizeof(*esph) + crypto_aead_ivsize(aead), elen);\n\tsg_init_one(asg, esph, sizeof(*esph));\n\n\taead_request_set_callback(req, 0, esp_input_done, skb);\n\taead_request_set_crypt(req, sg, sg, elen, iv);\n\taead_request_set_assoc(req, asg, sizeof(*esph));\n\n\tret = crypto_aead_decrypt(req);\n\tif (ret == -EINPROGRESS)\n\t\tgoto out;\n\n\tret = esp_input_done2(skb, ret);\n\nout:\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-16"], "project": "linux-2.6", "commit_id": "920fc941a9617f95ccb283037fe6f8a38d95bb69", "hash": 104942264381159022017048355767372737702, "size": 65, "message": "[ESP]: Ensure IV is in linear part of the skb to avoid BUG() due to OOB access\n\nESP does not account for the IV size when calling pskb_may_pull() to\nensure everything it accesses directly is within the linear part of a\npotential fragment. This results in a BUG() being triggered when the\nboth the IPv4 and IPv6 ESP stack is fed with an skb where the first\nfragment ends between the end of the esp header and the end of the IV.\n\nThis bug was found by Dirk Nehring <dnehring@gmx.net> .\n\nSigned-off-by: Thomas Graf <tgraf@suug.ch>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static int esp_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ip_esp_hdr *esph;\n\tstruct esp_data *esp = x->data;\n\tstruct crypto_aead *aead = esp->aead;\n\tstruct aead_request *req;\n\tstruct sk_buff *trailer;\n\tint elen = skb->len - sizeof(*esph) - crypto_aead_ivsize(aead);\n\tint nfrags;\n\tvoid *tmp;\n\tu8 *iv;\n\tstruct scatterlist *sg;\n\tstruct scatterlist *asg;\n\tint err = -EINVAL;\n\n\tif (!pskb_may_pull(skb, sizeof(*esph)))\n\t\tgoto out;\n\n\tif (elen <= 0)\n\t\tgoto out;\n\n\tif ((err = skb_cow_data(skb, 0, &trailer)) < 0)\n\t\tgoto out;\n\tnfrags = err;\n\n\terr = -ENOMEM;\n\ttmp = esp_alloc_tmp(aead, nfrags + 1);\n\tif (!tmp)\n\t\tgoto out;\n\n\tESP_SKB_CB(skb)->tmp = tmp;\n\tiv = esp_tmp_iv(aead, tmp);\n\treq = esp_tmp_req(aead, iv);\n\tasg = esp_req_sg(aead, req);\n\tsg = asg + 1;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tesph = (struct ip_esp_hdr *)skb->data;\n\n\t/* Get ivec. This can be wrong, check against another impls. */\n\tiv = esph->enc_data;\n\n\tsg_init_table(sg, nfrags);\n\tskb_to_sgvec(skb, sg, sizeof(*esph) + crypto_aead_ivsize(aead), elen);\n\tsg_init_one(asg, esph, sizeof(*esph));\n\n\taead_request_set_callback(req, 0, esp_input_done, skb);\n\taead_request_set_crypt(req, sg, sg, elen, iv);\n\taead_request_set_assoc(req, asg, sizeof(*esph));\n\n\terr = crypto_aead_decrypt(req);\n\tif (err == -EINPROGRESS)\n\t\tgoto out;\n\n\terr = esp_input_done2(skb, err);\n\nout:\n\treturn err;\n}", "target": 1, "cwe": ["CWE-16"], "project": "linux-2.6", "commit_id": "920fc941a9617f95ccb283037fe6f8a38d95bb69", "hash": 261859902457785342652484608745523864123, "size": 60, "message": "[ESP]: Ensure IV is in linear part of the skb to avoid BUG() due to OOB access\n\nESP does not account for the IV size when calling pskb_may_pull() to\nensure everything it accesses directly is within the linear part of a\npotential fragment. This results in a BUG() being triggered when the\nboth the IPv4 and IPv6 ESP stack is fed with an skb where the first\nfragment ends between the end of the esp header and the end of the IV.\n\nThis bug was found by Dirk Nehring <dnehring@gmx.net> .\n\nSigned-off-by: Thomas Graf <tgraf@suug.ch>\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(inode);\n\tisdn_ctrl c;\n\tint drvidx;\n\tint chidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\t\tcase IIOCGETDVR:\n\t\t\t\treturn (TTY_DV +\n\t\t\t\t\t(NET_DV << 8) +\n\t\t\t\t\t(INF_DV << 16));\n\t\t\tcase IIOCGETCPS:\n\t\t\t\tif (arg) {\n\t\t\t\t\tulong __user *p = argp;\n\t\t\t\t\tint i;\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, p,\n\t\t\t\t\t\t\tsizeof(ulong) * ISDN_MAX_CHANNELS * 2))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n#ifdef CONFIG_NETDEVICES\n\t\t\tcase IIOCNETGPN:\n\t\t\t\t/* Get peer phone number of a connected \n\t\t\t\t * isdn network interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n#endif\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tchidx = isdn_minor2chan(minor);\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefor, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\t\tcase IIOCNETDWRSET:\n\t\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\t\treturn(-EINVAL);\n\t\t\tcase IIOCNETLCR:\n\t\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\t\treturn -ENODEV;\n#ifdef CONFIG_NETDEVICES\n\t\t\tcase IIOCNETAIF:\n\t\t\t\t/* Add a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\ts = name;\n\t\t\t\t} else {\n\t\t\t\t\ts = NULL;\n\t\t\t\t}\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif( ret ) return ret;\n\t\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)){\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\tcase IIOCNETASL:\n\t\t\t\t/* Add a slave to a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\tif( ret ) return ret;\n\t\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)){\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\treturn ret;\n\t\t\tcase IIOCNETDIF:\n\t\t\t\t/* Delete a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_rm(name);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETSCF:\n\t\t\t\t/* Set configurable parameters of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_setcfg(&cfg);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETGCF:\n\t\t\t\t/* Get configurable parameters of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&cfg, argp, sizeof(cfg)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (!(ret = isdn_net_getcfg(&cfg))) {\n\t\t\t\t\t\tif (copy_to_user(argp, &cfg, sizeof(cfg)))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETANM:\n\t\t\t\t/* Add a phone-number to a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_addphone(&phone);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETGNM:\n\t\t\t\t/* Get list of phone-numbers of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_getphones(&phone, argp);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETDNM:\n\t\t\t\t/* Delete a phone-number of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\t\t\tif( ret ) return ret;\n\t\t\t\t\tret = isdn_net_delphone(&phone);\n\t\t\t\t\tmutex_unlock(&dev->mtx);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCNETDIL:\n\t\t\t\t/* Force dialing of a network-interface */\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn isdn_net_force_dial(name);\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n#ifdef CONFIG_ISDN_PPP\n\t\t\tcase IIOCNETALN:\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_ppp_dial_slave(name);\n\t\t\tcase IIOCNETDLN:\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_ppp_hangup_slave(name);\n#endif\n\t\t\tcase IIOCNETHUP:\n\t\t\t\t/* Force hangup of a network-interface */\n\t\t\t\tif (!arg)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_force_hangup(name);\n\t\t\t\tbreak;\n#endif                          /* CONFIG_NETDEVICES */\n\t\t\tcase IIOCSETVER:\n\t\t\t\tdev->net_verbose = arg;\n\t\t\t\tprintk(KERN_INFO \"isdn: Verbose-Level is %d\\n\", dev->net_verbose);\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSETGST:\n\t\t\t\tif (arg)\n\t\t\t\t\tdev->global_flags |= ISDN_GLOBAL_STOPPED;\n\t\t\t\telse\n\t\t\t\t\tdev->global_flags &= ~ISDN_GLOBAL_STOPPED;\n\t\t\t\tprintk(KERN_INFO \"isdn: Global Mode %s\\n\",\n\t\t\t\t       (dev->global_flags & ISDN_GLOBAL_STOPPED) ? \"stopped\" : \"running\");\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSETBRJ:\n\t\t\t\tdrvidx = -1;\n\t\t\t\tif (arg) {\n\t\t\t\t\tint i;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (drvidx == -1)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\tif (iocts.arg)\n\t\t\t\t\tdev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\n\t\t\t\telse\n\t\t\t\t\tdev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\n\t\t\t\treturn 0;\n\t\t\tcase IIOCSIGPRF:\n\t\t\t\tdev->profd = current;\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase IIOCGETPRF:\n\t\t\t\t/* Get all Modem-Profiles */\n\t\t\t\tif (arg) {\n\t\t\t\t\tchar __user *p = argp;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, argp,\n\t\t\t\t\t(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\n\t\t\t\t\t\t   * ISDN_MAX_CHANNELS))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.profile,\n\t\t\t\t\t\t      ISDN_MODEM_NUMREG))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\t\tif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\t}\n\t\t\t\t\treturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase IIOCSETPRF:\n\t\t\t\t/* Set all Modem-Profiles */\n\t\t\t\tif (arg) {\n\t\t\t\t\tchar __user *p = argp;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tif (!access_ok(VERIFY_READ, argp,\n\t\t\t\t\t(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\n\t\t\t\t\t\t   * ISDN_MAX_CHANNELS))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.profile, p,\n\t\t\t\t\t\t     ISDN_MODEM_NUMREG))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MODEM_NUMREG;\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_LMSNLEN;\n\t\t\t\t\t\tif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\n\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\tp += ISDN_MSNLEN;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase IIOCSETMAP:\n\t\t\tcase IIOCGETMAP:\n\t\t\t\t/* Set/Get MSN->EAZ-Mapping for a driver */\n\t\t\t\tif (arg) {\n\n\t\t\t\t\tif (copy_from_user(&iocts, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdrvidx = 0;\n\t\t\t\t\tif (drvidx == -1)\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\tif (cmd == IIOCSETMAP) {\n\t\t\t\t\t\tint loop = 1;\n\n\t\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (loop) {\n\t\t\t\t\t\t\tint j = 0;\n\n\t\t\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t\t\tif (!access_ok(VERIFY_READ, p, 1))\n\t\t\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\t\t\tget_user(bname[j], p++);\n\t\t\t\t\t\t\t\tswitch (bname[j]) {\n\t\t\t\t\t\t\t\t\tcase '\\0':\n\t\t\t\t\t\t\t\t\t\tloop = 0;\n\t\t\t\t\t\t\t\t\t\t/* Fall through */\n\t\t\t\t\t\t\t\t\tcase ',':\n\t\t\t\t\t\t\t\t\t\tbname[j] = '\\0';\n\t\t\t\t\t\t\t\t\t\tstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\n\t\t\t\t\t\t\t\t\t\tj = ISDN_MSNLEN;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (j >= ISDN_MSNLEN)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (++i > 9)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = (char __user *) iocts.arg;\n\t\t\t\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t\t\t\tsprintf(bname, \"%s%s\",\n\t\t\t\t\t\t\t\tstrlen(dev->drv[drvidx]->msn2eaz[i]) ?\n\t\t\t\t\t\t\t\tdev->drv[drvidx]->msn2eaz[i] : \"_\",\n\t\t\t\t\t\t\t\t(i < 9) ? \",\" : \"\\0\");\n\t\t\t\t\t\t\tif (copy_to_user(p, bname, strlen(bname) + 1))\n\t\t\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\t\t\tp += strlen(bname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\tcase IIOCDBGVAR:\n\t\t\t\tif (arg) {\n\t\t\t\t\tif (copy_to_user(argp, &dev, sizeof(ulong)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\n\t\t\t\t\tcmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\n\t\t\t\telse\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (arg) {\n\t\t\t\t\tint i;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tif (strlen(iocts.drvid)) {\n\t\t\t\t\t\tif ((p = strchr(iocts.drvid, ',')))\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tdrvidx = -1;\n\t\t\t\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t\t\t\tif (!(strcmp(dev->drvid[i], iocts.drvid))) {\n\t\t\t\t\t\t\t\tdrvidx = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdrvidx = 0;\n\t\t\t\t\tif (drvidx == -1)\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\tif (!access_ok(VERIFY_WRITE, argp,\n\t\t\t\t\t     sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tc.driver = drvidx;\n\t\t\t\t\tc.command = ISDN_CMD_IOCTL;\n\t\t\t\t\tc.arg = cmd;\n\t\t\t\t\tmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\n\t\t\t\t\tret = isdn_command(&c);\n\t\t\t\t\tmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\n\t\t\t\t\tif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\treturn ret;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n#ifdef CONFIG_ISDN_PPP\n\tif (minor <= ISDN_MINOR_PPPMAX)\n\t\treturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\n#endif\n\treturn -ENODEV;\n\n#undef name\n#undef bname\n#undef iocts\n#undef phone\n#undef cfg\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "eafe1aa37e6ec2d56f14732b5240c4dd09f0613a", "hash": 328221509131099860922910070027499343329, "size": 446, "message": "I4L: fix isdn_ioctl memory overrun vulnerability\n\nFix possible memory overrun issue in the isdn ioctl code.\n\nFound by ADLAB <adlab@venustech.com.cn>\n\nSigned-off-by: Karsten Keil <kkeil@suse.de>\nCc: ADLAB <adlab@venustech.com.cn>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "shmem_alloc_page(gfp_t gfp,struct shmem_inode_info *info, unsigned long idx)\n{\n\treturn alloc_page(gfp | __GFP_ZERO);\n}", "target": 1, "cwe": ["CWE-200"], "project": "linux-2.6", "commit_id": "e84e2e132c9c66d8498e7710d4ea532d1feaaac5", "hash": 40898721436560148466228075046362201453, "size": 4, "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int shmem_getpage(struct inode *inode, unsigned long idx,\n\t\t\tstruct page **pagep, enum sgp_type sgp, int *type)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tstruct shmem_sb_info *sbinfo;\n\tstruct page *filepage = *pagep;\n\tstruct page *swappage;\n\tswp_entry_t *entry;\n\tswp_entry_t swap;\n\tint error;\n\n\tif (idx >= SHMEM_MAX_INDEX)\n\t\treturn -EFBIG;\n\n\tif (type)\n\t\t*type = 0;\n\n\t/*\n\t * Normally, filepage is NULL on entry, and either found\n\t * uptodate immediately, or allocated and zeroed, or read\n\t * in under swappage, which is then assigned to filepage.\n\t * But shmem_readpage and shmem_write_begin pass in a locked\n\t * filepage, which may be found not uptodate by other callers\n\t * too, and may need to be copied from the swappage read in.\n\t */\nrepeat:\n\tif (!filepage)\n\t\tfilepage = find_lock_page(mapping, idx);\n\tif (filepage && PageUptodate(filepage))\n\t\tgoto done;\n\terror = 0;\n\tif (sgp == SGP_QUICK)\n\t\tgoto failed;\n\n\tspin_lock(&info->lock);\n\tshmem_recalc_inode(inode);\n\tentry = shmem_swp_alloc(info, idx, sgp);\n\tif (IS_ERR(entry)) {\n\t\tspin_unlock(&info->lock);\n\t\terror = PTR_ERR(entry);\n\t\tgoto failed;\n\t}\n\tswap = *entry;\n\n\tif (swap.val) {\n\t\t/* Look it up and read it in.. */\n\t\tswappage = lookup_swap_cache(swap);\n\t\tif (!swappage) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\t/* here we actually do the io */\n\t\t\tif (type && !(*type & VM_FAULT_MAJOR)) {\n\t\t\t\t__count_vm_event(PGMAJFAULT);\n\t\t\t\t*type |= VM_FAULT_MAJOR;\n\t\t\t}\n\t\t\tspin_unlock(&info->lock);\n\t\t\tswappage = shmem_swapin(info, swap, idx);\n\t\t\tif (!swappage) {\n\t\t\t\tspin_lock(&info->lock);\n\t\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\t\tif (IS_ERR(entry))\n\t\t\t\t\terror = PTR_ERR(entry);\n\t\t\t\telse {\n\t\t\t\t\tif (entry->val == swap.val)\n\t\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\t/* We have to do this with page locked to prevent races */\n\t\tif (TestSetPageLocked(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (PageWriteback(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_writeback(swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!PageUptodate(swappage)) {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\terror = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (filepage) {\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tdelete_from_swap_cache(swappage);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tcopy_highpage(filepage, swappage);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tflush_dcache_page(filepage);\n\t\t\tSetPageUptodate(filepage);\n\t\t\tset_page_dirty(filepage);\n\t\t\tswap_free(swap);\n\t\t} else if (!(error = move_from_swap_cache(\n\t\t\t\tswappage, idx, mapping))) {\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t\tshmem_swp_set(info, entry, 0);\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = swappage;\n\t\t\tswap_free(swap);\n\t\t} else {\n\t\t\tshmem_swp_unmap(entry);\n\t\t\tspin_unlock(&info->lock);\n\t\t\tunlock_page(swappage);\n\t\t\tpage_cache_release(swappage);\n\t\t\tif (error == -ENOMEM) {\n\t\t\t\t/* let kswapd refresh zone for GFP_ATOMICs */\n\t\t\t\tcongestion_wait(WRITE, HZ/50);\n\t\t\t}\n\t\t\tgoto repeat;\n\t\t}\n\t} else if (sgp == SGP_READ && !filepage) {\n\t\tshmem_swp_unmap(entry);\n\t\tfilepage = find_get_page(mapping, idx);\n\t\tif (filepage &&\n\t\t    (!PageUptodate(filepage) || TestSetPageLocked(filepage))) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\twait_on_page_locked(filepage);\n\t\t\tpage_cache_release(filepage);\n\t\t\tfilepage = NULL;\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&info->lock);\n\t} else {\n\t\tshmem_swp_unmap(entry);\n\t\tsbinfo = SHMEM_SB(inode->i_sb);\n\t\tif (sbinfo->max_blocks) {\n\t\t\tspin_lock(&sbinfo->stat_lock);\n\t\t\tif (sbinfo->free_blocks == 0 ||\n\t\t\t    shmem_acct_block(info->flags)) {\n\t\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\terror = -ENOSPC;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tsbinfo->free_blocks--;\n\t\t\tinode->i_blocks += BLOCKS_PER_PAGE;\n\t\t\tspin_unlock(&sbinfo->stat_lock);\n\t\t} else if (shmem_acct_block(info->flags)) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\terror = -ENOSPC;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!filepage) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\tfilepage = shmem_alloc_page(mapping_gfp_mask(mapping),\n\t\t\t\t\t\t    info,\n\t\t\t\t\t\t    idx);\n\t\t\tif (!filepage) {\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tspin_lock(&info->lock);\n\t\t\tentry = shmem_swp_alloc(info, idx, sgp);\n\t\t\tif (IS_ERR(entry))\n\t\t\t\terror = PTR_ERR(entry);\n\t\t\telse {\n\t\t\t\tswap = *entry;\n\t\t\t\tshmem_swp_unmap(entry);\n\t\t\t}\n\t\t\tif (error || swap.val || 0 != add_to_page_cache_lru(\n\t\t\t\t\tfilepage, mapping, idx, GFP_ATOMIC)) {\n\t\t\t\tspin_unlock(&info->lock);\n\t\t\t\tpage_cache_release(filepage);\n\t\t\t\tshmem_unacct_blocks(info->flags, 1);\n\t\t\t\tshmem_free_blocks(inode, 1);\n\t\t\t\tfilepage = NULL;\n\t\t\t\tif (error)\n\t\t\t\t\tgoto failed;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tinfo->flags |= SHMEM_PAGEIN;\n\t\t}\n\n\t\tinfo->alloced++;\n\t\tspin_unlock(&info->lock);\n\t\tflush_dcache_page(filepage);\n\t\tSetPageUptodate(filepage);\n\t}\ndone:\n\tif (*pagep != filepage) {\n\t\t*pagep = filepage;\n\t\tif (sgp != SGP_FAULT)\n\t\t\tunlock_page(filepage);\n\n\t}\n\treturn 0;\n\nfailed:\n\tif (*pagep != filepage) {\n\t\tunlock_page(filepage);\n\t\tpage_cache_release(filepage);\n\t}\n\treturn error;\n}", "target": 1, "cwe": ["CWE-200"], "project": "linux-2.6", "commit_id": "e84e2e132c9c66d8498e7710d4ea532d1feaaac5", "hash": 337224798820921138280301426323775912767, "size": 221, "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "shmem_alloc_page(gfp_t gfp, struct shmem_inode_info *info,\n\t\t unsigned long idx)\n{\n\tstruct vm_area_struct pvma;\n\tstruct page *page;\n\n\tmemset(&pvma, 0, sizeof(struct vm_area_struct));\n\tpvma.vm_policy = mpol_shared_policy_lookup(&info->policy, idx);\n\tpvma.vm_pgoff = idx;\n\tpvma.vm_end = PAGE_SIZE;\n\tpage = alloc_page_vma(gfp | __GFP_ZERO, &pvma, 0);\n\tmpol_free(pvma.vm_policy);\n\treturn page;\n}", "target": 1, "cwe": ["CWE-200"], "project": "linux-2.6", "commit_id": "e84e2e132c9c66d8498e7710d4ea532d1feaaac5", "hash": 209078005530362263064364667908690042525, "size": 14, "message": "tmpfs: restore missing clear_highpage\n\ntmpfs was misconverted to __GFP_ZERO in 2.6.11.  There's an unusual case in\nwhich shmem_getpage receives the page from its caller instead of allocating.\nWe must cover this case by clear_highpage before SetPageUptodate, as before.\n\nSigned-off-by: Hugh Dickins <hugh@veritas.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "ProcShmCreatePixmap(client)\n    register ClientPtr client;\n{\n    PixmapPtr pMap;\n    DrawablePtr pDraw;\n    DepthPtr pDepth;\n    register int i, rc;\n    ShmDescPtr shmdesc;\n    REQUEST(xShmCreatePixmapReq);\n    unsigned int width, height, depth;\n    unsigned long size;\n\n    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);\n    client->errorValue = stuff->pid;\n    if (!sharedPixmaps)\n\treturn BadImplementation;\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,\n\t\t\t   DixGetAttrAccess);\n    if (rc != Success)\n\treturn rc;\n\n    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);\n    \n    width = stuff->width;\n    height = stuff->height;\n    depth = stuff->depth;\n    if (!width || !height || !depth)\n    {\n\tclient->errorValue = 0;\n        return BadValue;\n    }\n    if (width > 32767 || height > 32767)\n\treturn BadAlloc;\n\n    if (stuff->depth != 1)\n    {\n        pDepth = pDraw->pScreen->allowedDepths;\n        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)\n\t   if (pDepth->depth == stuff->depth)\n               goto CreatePmap;\n\tclient->errorValue = stuff->depth;\n        return BadValue;\n    }\n\nCreatePmap:\n    size = PixmapBytePad(width, depth) * height;\n    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {\n\tif (size < width * height)\n\t    return BadAlloc;\n\t/* thankfully, offset is unsigned */\n\tif (stuff->offset + size < size)\n\t    return BadAlloc;\n    }\n\n    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);\n    pMap = (*shmFuncs[pDraw->pScreen->myNum]->CreatePixmap)(\n\t\t\t    pDraw->pScreen, stuff->width,\n\t\t\t    stuff->height, stuff->depth,\n\t\t\t    shmdesc->addr + stuff->offset);\n    if (pMap)\n    {\n\trc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,\n\t\t      pMap, RT_NONE, NULL, DixCreateAccess);\n\tif (rc != Success) {\n\t    pDraw->pScreen->DestroyPixmap(pMap);\n\t    return rc;\n\t}\n\tdixSetPrivate(&pMap->devPrivates, shmPixmapPrivate, shmdesc);\n\tshmdesc->refcnt++;\n\tpMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;\n\tpMap->drawable.id = stuff->pid;\n\tif (AddResource(stuff->pid, RT_PIXMAP, (pointer)pMap))\n\t{\n\t    return(client->noClientException);\n\t}\n\tpDraw->pScreen->DestroyPixmap(pMap);\n    }\n    return (BadAlloc);\n}", "target": 1, "cwe": ["CWE-189"], "project": "xserver", "commit_id": "be6c17fcf9efebc0bbcc3d9a25f8c5a2450c2161", "hash": 129275241199461482775430751894790125185, "size": 80, "message": "CVE-2007-6429: Always test for size+offset wrapping."}
{"func": "ProcPanoramiXShmCreatePixmap(\n    register ClientPtr client)\n{\n    ScreenPtr pScreen = NULL;\n    PixmapPtr pMap = NULL;\n    DrawablePtr pDraw;\n    DepthPtr pDepth;\n    int i, j, result, rc;\n    ShmDescPtr shmdesc;\n    REQUEST(xShmCreatePixmapReq);\n    unsigned int width, height, depth;\n    unsigned long size;\n    PanoramiXRes *newPix;\n\n    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);\n    client->errorValue = stuff->pid;\n    if (!sharedPixmaps)\n\treturn BadImplementation;\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,\n\t\t\t   DixUnknownAccess);\n    if (rc != Success)\n\treturn rc;\n\n    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);\n\n    width = stuff->width;\n    height = stuff->height;\n    depth = stuff->depth;\n    if (!width || !height || !depth)\n    {\n\tclient->errorValue = 0;\n        return BadValue;\n    }\n    if (width > 32767 || height > 32767)\n        return BadAlloc;\n\n    if (stuff->depth != 1)\n    {\n        pDepth = pDraw->pScreen->allowedDepths;\n        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)\n\t   if (pDepth->depth == stuff->depth)\n               goto CreatePmap;\n\tclient->errorValue = stuff->depth;\n        return BadValue;\n    }\n\nCreatePmap:\n    size = PixmapBytePad(width, depth) * height;\n    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {\n        if (size < width * height)\n            return BadAlloc;\n        /* thankfully, offset is unsigned */\n        if (stuff->offset + size < size)\n            return BadAlloc;\n    }\n\n    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);\n\n    if(!(newPix = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))\n\treturn BadAlloc;\n\n    newPix->type = XRT_PIXMAP;\n    newPix->u.pix.shared = TRUE;\n    newPix->info[0].id = stuff->pid;\n    for(j = 1; j < PanoramiXNumScreens; j++)\n\tnewPix->info[j].id = FakeClientID(client->index);\n\n    result = (client->noClientException);\n\n    FOR_NSCREENS(j) {\n\tpScreen = screenInfo.screens[j];\n\n\tpMap = (*shmFuncs[j]->CreatePixmap)(pScreen, \n\t\t\t\tstuff->width, stuff->height, stuff->depth,\n\t\t\t\tshmdesc->addr + stuff->offset);\n\n\tif (pMap) {\n\t    dixSetPrivate(&pMap->devPrivates, shmPixmapPrivate, shmdesc);\n            shmdesc->refcnt++;\n\t    pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;\n\t    pMap->drawable.id = newPix->info[j].id;\n\t    if (!AddResource(newPix->info[j].id, RT_PIXMAP, (pointer)pMap)) {\n\t\t(*pScreen->DestroyPixmap)(pMap);\n\t\tresult = BadAlloc;\n\t\tbreak;\n\t    }\n\t} else {\n\t   result = BadAlloc;\n\t   break;\n\t}\n    }\n\n    if(result == BadAlloc) {\n\twhile(j--) {\n\t    (*pScreen->DestroyPixmap)(pMap);\n\t    FreeResource(newPix->info[j].id, RT_NONE);\n\t}\n\txfree(newPix);\n    } else \n\tAddResource(stuff->pid, XRT_PIXMAP, newPix);\n\n    return result;\n}", "target": 1, "cwe": ["CWE-189"], "project": "xserver", "commit_id": "be6c17fcf9efebc0bbcc3d9a25f8c5a2450c2161", "hash": 17219291516037378365261386718006722853, "size": 104, "message": "CVE-2007-6429: Always test for size+offset wrapping."}
{"func": "static int copy_from_user_mmap_sem(void *dst, const void __user *src, size_t n)\n{\n\tint partial;\n\n\tpagefault_disable();\n\tpartial = __copy_from_user_inatomic(dst, src, n);\n\tpagefault_enable();\n\n\t/*\n\t * Didn't copy everything, drop the mmap_sem and do a faulting copy\n\t */\n\tif (unlikely(partial)) {\n\t\tup_read(&current->mm->mmap_sem);\n\t\tpartial = copy_from_user(dst, src, n);\n\t\tdown_read(&current->mm->mmap_sem);\n\t}\n\n\treturn partial;\n}", "target": 1, "cwe": ["CWE-94"], "project": "linux-2.6", "commit_id": "8811930dc74a503415b35c4a79d14fb0b408a361", "hash": 235093879813159381271611100311257866404, "size": 19, "message": "splice: missing user pointer access verification\n\nvmsplice_to_user() must always check the user pointer and length\nwith access_ok() before copying. Likewise, for the slow path of\ncopy_from_user_mmap_sem() we need to check that we may read from\nthe user region.\n\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>\nCc: Wojciech Purczynski <cliph@research.coseinc.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static long vmsplice_to_user(struct file *file, const struct iovec __user *iov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct splice_desc sd;\n\tssize_t size;\n\tint error;\n\tlong ret;\n\n\tpipe = pipe_info(file->f_path.dentry->d_inode);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (pipe->inode)\n\t\tmutex_lock(&pipe->inode->i_mutex);\n\n\terror = ret = 0;\n\twhile (nr_segs) {\n\t\tvoid __user *base;\n\t\tsize_t len;\n\n\t\t/*\n\t\t * Get user address base and length for this iovec.\n\t\t */\n\t\terror = get_user(base, &iov->iov_base);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = get_user(len, &iov->iov_len);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\tif (unlikely(!base)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsd.len = 0;\n\t\tsd.total_len = len;\n\t\tsd.flags = flags;\n\t\tsd.u.userptr = base;\n\t\tsd.pos = 0;\n\n\t\tsize = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\t\tif (size < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = size;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tret += size;\n\n\t\tif (size < len)\n\t\t\tbreak;\n\n\t\tnr_segs--;\n\t\tiov++;\n\t}\n\n\tif (pipe->inode)\n\t\tmutex_unlock(&pipe->inode->i_mutex);\n\n\tif (!ret)\n\t\tret = error;\n\n\treturn ret;\n}", "target": 1, "cwe": ["CWE-94"], "project": "linux-2.6", "commit_id": "8811930dc74a503415b35c4a79d14fb0b408a361", "hash": 93812929696679570671165480928317227145, "size": 72, "message": "splice: missing user pointer access verification\n\nvmsplice_to_user() must always check the user pointer and length\nwith access_ok() before copying. Likewise, for the slow path of\ncopy_from_user_mmap_sem() we need to check that we may read from\nthe user region.\n\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>\nCc: Wojciech Purczynski <cliph@research.coseinc.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\n\tdown_read(&current->mm->mmap_sem);\n\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get this base offset and number of pages, then map\n\t\t * in the user pages.\n\t\t */\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\n\t\t/*\n\t\t * If asked for alignment, the offset must be zero and the\n\t\t * length a multiple of the PAGE_SIZE.\n\t\t */\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Fill this contiguous range into the partial page map.\n\t\t */\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\n\t\t/*\n\t\t * We didn't complete this iov, stop here since it probably\n\t\t * means we have to move some of this into a pipe to\n\t\t * be able to continue.\n\t\t */\n\t\tif (len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't continue if we mapped fewer pages than we asked for,\n\t\t * or if we mapped the max number of pages that we have\n\t\t * room for.\n\t\t */\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\n\tup_read(&current->mm->mmap_sem);\n\n\tif (buffers)\n\t\treturn buffers;\n\n\treturn error;\n}", "target": 1, "cwe": ["CWE-94"], "project": "linux-2.6", "commit_id": "712a30e63c8066ed84385b12edbfb804f49cbc44", "hash": 235267654020111867894816915382074891733, "size": 98, "message": "splice: fix user pointer access in get_iovec_page_array()\n\nCommit 8811930dc74a503415b35c4a79d14fb0b408a361 (\"splice: missing user\npointer access verification\") added the proper access_ok() calls to\ncopy_from_user_mmap_sem() which ensures we can copy the struct iovecs\nfrom userspace to the kernel.\n\nBut we also must check whether we can access the actual memory region\npointed to by the struct iovec to fix the access checks properly.\n\nSigned-off-by: Bastian Blank <waldi@debian.org>\nAcked-by: Oliver Pinter <oliver.pntr@gmail.com>\nCc: Jens Axboe <jens.axboe@oracle.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Pekka Enberg <penberg@cs.helsinki.fi>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tif (rlim_cur == 0) {\n\t\t\t/*\n\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t\t * never set\".  So let's cheat and make it one second\n\t\t\t * instead\n\t\t\t */\n\t\t\trlim_cur = 1;\n\t\t}\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "9926e4c74300c4b31dee007298c6475d33369df0", "hash": 53303886230877642634155857946902981974, "size": 63, "message": "CPU time limit patch / setrlimit(RLIMIT_CPU, 0) cheat fix\n\nAs discovered here today, the change in Kernel 2.6.17 intended to inhibit\nusers from setting RLIMIT_CPU to 0 (as that is equivalent to unlimited) by\n\"cheating\" and setting it to 1 in such a case, does not make a difference,\nas the check is done in the wrong place (too late), and only applies to the\nprofiling code.\n\nOn all systems I checked running kernels above 2.6.17, no matter what the\nhard and soft CPU time limits were before, a user could escape them by\nissuing in the shell (sh/bash/zsh) \"ulimit -t 0\", and then the user's\nprocess was not ever killed.\n\nAttached is a trivial patch to fix that.  Simply moving the check to a\nslightly earlier location (specifically, before the line that actually\nassigns the limit - *old_rlim = new_rlim), does the trick.\n\nDo note that at least the zsh (but not ash, dash, or bash) shell has the\nproblem of \"caching\" the limits set by the ulimit command, so when running\nzsh the fix will not immediately be evident - after entering \"ulimit -t 0\",\n\"ulimit -a\" will show \"-t: cpu time (seconds) 0\", even though the actual\nlimit as returned by getrlimit(...) will be 1.  It can be verified by\nopening a subshell (which will not have the values of the parent shell in\ncache) and checking in it, or just by running a CPU intensive command like\n\"echo '65536^1048576' | bc\" and verifying that it dumps core after one\nsecond.\n\nRegardless of whether that is a misfeature in the shell, perhaps it would\nbe better to return -EINVAL from setrlimit in such a case instead of\ncheating and setting to 1, as that does not really reflect the actual state\nof the process anymore.  I do not however know what the ground for that\ndecision was in the original 2.6.17 change, and whether there would be any\n\"backward\" compatibility issues, so I preferred not to touch that right\nnow.\n\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\t   sigset_t *set, struct pt_regs * regs)\n{\n\tvoid __user *restorer;\n\tstruct rt_sigframe __user *frame;\n\tint err = 0;\n\tint usig;\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tusig = current_thread_info()->exec_domain\n\t\t&& current_thread_info()->exec_domain->signal_invmap\n\t\t&& sig < 32\n\t\t? current_thread_info()->exec_domain->signal_invmap[sig]\n\t\t: sig;\n\n\terr |= __put_user(usig, &frame->sig);\n\terr |= __put_user(&frame->info, &frame->pinfo);\n\terr |= __put_user(&frame->uc, &frame->puc);\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\t\t\t        regs, set->sig[0]);\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up to return from userspace.  */\n\trestorer = VDSO32_SYMBOL(current->mm->context.vdso, rt_sigreturn);\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\terr |= __put_user(restorer, &frame->pretcode);\n\t \n\t/*\n\t * This is movl $,%ax ; int $0x80\n\t *\n\t * WE DO NOT USE IT ANY MORE! It's only left here for historical\n\t * reasons and because gdb uses it as a signature to notice\n\t * signal handler stack frames.\n\t */\n\terr |= __put_user(0xb8, (char __user *)(frame->retcode+0));\n\terr |= __put_user(__NR_rt_sigreturn, (int __user *)(frame->retcode+1));\n\terr |= __put_user(0x80cd, (short __user *)(frame->retcode+5));\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\tregs->ax = (unsigned long) usig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\tregs->ds = __USER_DS;\n\tregs->es = __USER_DS;\n\tregs->ss = __USER_DS;\n\tregs->cs = __USER_CS;\n\n\t/*\n\t * Clear TF when entering the signal handler, but\n\t * notify any tracer that was single-stepping it.\n\t * The tracer may want to single-step inside the\n\t * handler too.\n\t */\n\tregs->flags &= ~TF_MASK;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%p ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "e40cd10ccff3d9fbffd57b93780bee4b7b9bff51", "hash": 25210609055917764870719712764967878905, "size": 92, "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "int ia32_setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\tcompat_sigset_t *set, struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tstruct exec_domain *ed = current_thread_info()->exec_domain;\n\tvoid __user *restorer;\n\tint err = 0;\n\n\t/* __copy_to_user optimizes that into a single 8 byte store */\n\tstatic const struct {\n\t\tu8 movl;\n\t\tu32 val;\n\t\tu16 int80;\n\t\tu16 pad;\n\t\tu8  pad2;\n\t} __attribute__((packed)) code = {\n\t\t0xb8,\n\t\t__NR_ia32_rt_sigreturn,\n\t\t0x80cd,\n\t\t0,\n\t};\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\terr |= __put_user((ed && ed->signal_invmap && sig < 32\n\t\t\t   ? ed->signal_invmap[sig] : sig), &frame->sig);\n\terr |= __put_user(ptr_to_compat(&frame->info), &frame->pinfo);\n\terr |= __put_user(ptr_to_compat(&frame->uc), &frame->puc);\n\terr |= copy_siginfo_to_user32(&frame->info, info);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= ia32_setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\t\t\t\t     regs, set->sig[0]);\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\telse\n\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso,\n\t\t\t\t\t rt_sigreturn);\n\terr |= __put_user(ptr_to_compat(restorer), &frame->pretcode);\n\n\t/*\n\t * Not actually used anymore, but left because some gdb\n\t * versions need it.\n\t */\n\terr |= __copy_to_user(frame->retcode, &code, 8);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = (unsigned long) &frame->info;\n\tregs->cx = (unsigned long) &frame->uc;\n\n\tasm volatile(\"movl %0,%%ds\" :: \"r\" (__USER32_DS));\n\tasm volatile(\"movl %0,%%es\" :: \"r\" (__USER32_DS));\n\n\tregs->cs = __USER32_CS;\n\tregs->ss = __USER32_DS;\n\n\tset_fs(USER_DS);\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(KERN_DEBUG \"SIG deliver (%s:%d): sp=%p pc=%lx ra=%u\\n\",\n\t       current->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "e40cd10ccff3d9fbffd57b93780bee4b7b9bff51", "hash": 336026717347518607266497936354610258572, "size": 99, "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n\t\t\t   sigset_t *set, struct pt_regs * regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tstruct _fpstate __user *fp = NULL; \n\tint err = 0;\n\tstruct task_struct *me = current;\n\n\tif (used_math()) {\n\t\tfp = get_stack(ka, regs, sizeof(struct _fpstate)); \n\t\tframe = (void __user *)round_down(\n\t\t\t(unsigned long)fp - sizeof(struct rt_sigframe), 16) - 8;\n\n\t\tif (!access_ok(VERIFY_WRITE, fp, sizeof(struct _fpstate)))\n\t\t\tgoto give_sigsegv;\n\n\t\tif (save_i387(fp) < 0) \n\t\t\terr |= -1; \n\t} else\n\t\tframe = get_stack(ka, regs, sizeof(struct rt_sigframe)) - 8;\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tif (ka->sa.sa_flags & SA_SIGINFO) { \n\t\terr |= copy_siginfo_to_user(&frame->info, info);\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\t\t\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __put_user(0, &frame->uc.uc_link);\n\terr |= __put_user(me->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\n\terr |= __put_user(sas_ss_flags(regs->sp),\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\terr |= __put_user(me->sas_ss_size, &frame->uc.uc_stack.ss_size);\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, regs, set->sig[0], me);\n\terr |= __put_user(fp, &frame->uc.uc_mcontext.fpstate);\n\tif (sizeof(*set) == 16) { \n\t\t__put_user(set->sig[0], &frame->uc.uc_sigmask.sig[0]);\n\t\t__put_user(set->sig[1], &frame->uc.uc_sigmask.sig[1]); \n\t} else\n\t\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\t   already in userspace.  */\n\t/* x86-64 should always use SA_RESTORER. */\n\tif (ka->sa.sa_flags & SA_RESTORER) {\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\t} else {\n\t\t/* could use a vstub here */\n\t\tgoto give_sigsegv; \n\t}\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n#ifdef DEBUG_SIG\n\tprintk(\"%d old ip %lx old sp %lx old ax %lx\\n\", current->pid,regs->ip,regs->sp,regs->ax);\n#endif\n\n\t/* Set up registers for signal handler */\n\tregs->di = sig;\n\t/* In case the signal handler was declared without prototypes */ \n\tregs->ax = 0;\n\n\t/* This also works for non SA_SIGINFO handlers because they expect the\n\t   next argument after the signal number on the stack. */\n\tregs->si = (unsigned long)&frame->info;\n\tregs->dx = (unsigned long)&frame->uc;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\tregs->sp = (unsigned long)frame;\n\n\t/* Set up the CS register to run signal handlers in 64-bit mode,\n\t   even if the handler happens to be interrupting 32-bit code. */\n\tregs->cs = __USER_CS;\n\n\t/* This, by contrast, has nothing to do with segment registers -\n\t   see include/asm-x86_64/uaccess.h for details. */\n\tset_fs(USER_DS);\n\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n#ifdef DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%lx ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "e40cd10ccff3d9fbffd57b93780bee4b7b9bff51", "hash": 323536889097069150889416252395929520907, "size": 97, "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "static int setup_frame(int sig, struct k_sigaction *ka,\n\t\t       sigset_t *set, struct pt_regs * regs)\n{\n\tvoid __user *restorer;\n\tstruct sigframe __user *frame;\n\tint err = 0;\n\tint usig;\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\tusig = current_thread_info()->exec_domain\n\t\t&& current_thread_info()->exec_domain->signal_invmap\n\t\t&& sig < 32\n\t\t? current_thread_info()->exec_domain->signal_invmap[sig]\n\t\t: sig;\n\n\terr = __put_user(usig, &frame->sig);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\terr = setup_sigcontext(&frame->sc, &frame->fpstate, regs, set->sig[0]);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (_NSIG_WORDS > 1) {\n\t\terr = __copy_to_user(&frame->extramask, &set->sig[1],\n\t\t\t\t      sizeof(frame->extramask));\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\n\tif (current->binfmt->hasvdso)\n\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso, sigreturn);\n\telse\n\t\trestorer = &frame->retcode;\n\tif (ka->sa.sa_flags & SA_RESTORER)\n\t\trestorer = ka->sa.sa_restorer;\n\n\t/* Set up to return from userspace.  */\n\terr |= __put_user(restorer, &frame->pretcode);\n\t \n\t/*\n\t * This is popl %eax ; movl $,%eax ; int $0x80\n\t *\n\t * WE DO NOT USE IT ANY MORE! It's only left here for historical\n\t * reasons and because gdb uses it as a signature to notice\n\t * signal handler stack frames.\n\t */\n\terr |= __put_user(0xb858, (short __user *)(frame->retcode+0));\n\terr |= __put_user(__NR_sigreturn, (int __user *)(frame->retcode+2));\n\terr |= __put_user(0x80cd, (short __user *)(frame->retcode+6));\n\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\tregs->ax = (unsigned long) sig;\n\tregs->dx = (unsigned long) 0;\n\tregs->cx = (unsigned long) 0;\n\n\tregs->ds = __USER_DS;\n\tregs->es = __USER_DS;\n\tregs->ss = __USER_DS;\n\tregs->cs = __USER_CS;\n\n\t/*\n\t * Clear TF when entering the signal handler, but\n\t * notify any tracer that was single-stepping it.\n\t * The tracer may want to single-step inside the\n\t * handler too.\n\t */\n\tregs->flags &= ~TF_MASK;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(\"SIG deliver (%s:%d): sp=%p pc=%p ra=%p\\n\",\n\t\tcurrent->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "e40cd10ccff3d9fbffd57b93780bee4b7b9bff51", "hash": 240195482991768344151461321121195113778, "size": 91, "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "int ia32_setup_frame(int sig, struct k_sigaction *ka,\n\t\t     compat_sigset_t *set, struct pt_regs *regs)\n{\n\tstruct sigframe __user *frame;\n\tvoid __user *restorer;\n\tint err = 0;\n\n\t/* copy_to_user optimizes that into a single 8 byte store */\n\tstatic const struct {\n\t\tu16 poplmovl;\n\t\tu32 val;\n\t\tu16 int80;\n\t\tu16 pad;\n\t} __attribute__((packed)) code = {\n\t\t0xb858,\t\t /* popl %eax ; movl $...,%eax */\n\t\t__NR_ia32_sigreturn,\n\t\t0x80cd,\t\t/* int $0x80 */\n\t\t0,\n\t};\n\n\tframe = get_sigframe(ka, regs, sizeof(*frame));\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\t\tgoto give_sigsegv;\n\n\terr |= __put_user(sig, &frame->sig);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\terr |= ia32_setup_sigcontext(&frame->sc, &frame->fpstate, regs,\n\t\t\t\t\tset->sig[0]);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\tif (_COMPAT_NSIG_WORDS > 1) {\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\t\t\t\t      sizeof(frame->extramask));\n\t\tif (err)\n\t\t\tgoto give_sigsegv;\n\t}\n\n\tif (ka->sa.sa_flags & SA_RESTORER) {\n\t\trestorer = ka->sa.sa_restorer;\n\t} else {\n\t\t/* Return stub is in 32bit vsyscall page */\n\t\tif (current->binfmt->hasvdso)\n\t\t\trestorer = VDSO32_SYMBOL(current->mm->context.vdso,\n\t\t\t\t\t\t sigreturn);\n\t\telse\n\t\t\trestorer = &frame->retcode;\n\t}\n\terr |= __put_user(ptr_to_compat(restorer), &frame->pretcode);\n\n\t/*\n\t * These are actually not used anymore, but left because some\n\t * gdb versions depend on them as a marker.\n\t */\n\terr |= __copy_to_user(frame->retcode, &code, 8);\n\tif (err)\n\t\tgoto give_sigsegv;\n\n\t/* Set up registers for signal handler */\n\tregs->sp = (unsigned long) frame;\n\tregs->ip = (unsigned long) ka->sa.sa_handler;\n\n\t/* Make -mregparm=3 work */\n\tregs->ax = sig;\n\tregs->dx = 0;\n\tregs->cx = 0;\n\n\tasm volatile(\"movl %0,%%ds\" :: \"r\" (__USER32_DS));\n\tasm volatile(\"movl %0,%%es\" :: \"r\" (__USER32_DS));\n\n\tregs->cs = __USER32_CS;\n\tregs->ss = __USER32_DS;\n\n\tset_fs(USER_DS);\n\tregs->flags &= ~X86_EFLAGS_TF;\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\tptrace_notify(SIGTRAP);\n\n#if DEBUG_SIG\n\tprintk(KERN_DEBUG \"SIG deliver (%s:%d): sp=%p pc=%lx ra=%u\\n\",\n\t       current->comm, current->pid, frame, regs->ip, frame->pretcode);\n#endif\n\n\treturn 0;\n\ngive_sigsegv:\n\tforce_sigsegv(sig, current);\n\treturn -EFAULT;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "e40cd10ccff3d9fbffd57b93780bee4b7b9bff51", "hash": 242893451020799354943598531577743834358, "size": 92, "message": "x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86/x86-64 ABI requires that.\n\nLinux had this behavior/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>"}
{"func": "static unsigned long __peek_user(struct task_struct *child, addr_t addr)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset, tmp;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\ttmp = *(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr);\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask)\n\t\t\t/* Remove per bit from user psw. */\n\t\t\ttmp &= ~PSW_MASK_PER;\n\n\t} else if (addr < (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb reading\n\t\t * from acrs[15]. Result is a 64 bit value. Read the\n\t\t * 32 bit acrs[15] value and shift it by 32. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\ttmp = ((unsigned long) child->thread.acrs[15]) << 32;\n\t\telse\n#endif\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = (addr_t) task_pt_regs(child)->orig_gpr2;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/* \n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.fp_regs + offset);\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\ttmp &= (unsigned long) FPC_VALID_MASK\n\t\t\t\t<< (BITS_PER_LONG - 32);\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.per_info;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.per_info + offset);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "3d6e48f43340343d97839eadb1ab7b6a3ea98797", "hash": 228545314486915469738309849042034394364, "size": 59, "message": "[S390] CVE-2008-1514: prevent ptrace padding area read/write in 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>"}
{"func": "static int __poke_user_compat(struct task_struct *child,\n\t\t\t      addr_t addr, addr_t data)\n{\n\tstruct user32 *dummy32 = NULL;\n\tper_struct32 *dummy_per32 = NULL;\n\t__u32 tmp = (__u32) data;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\t/*\n\t\t * psw, gprs, acrs and orig_gpr2 are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t/* Build a 64 bit psw mask from 31 bit mask. */\n\t\t\tif (tmp != PSW32_MASK_MERGE(psw32_user_bits, tmp))\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\ttask_pt_regs(child)->psw.mask =\n\t\t\t\tPSW_MASK_MERGE(psw_user32_bits, (__u64) tmp << 32);\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Build a 64 bit psw address from 31 bit address. */\n\t\t\ttask_pt_regs(child)->psw.addr =\n\t\t\t\t(__u64) tmp & PSW32_ADDR_INSN;\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\t*(__u32*)((addr_t) &task_pt_regs(child)->psw\n\t\t\t\t  + addr*2 + 4) = tmp;\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\t*(__u32*)((addr_t) &child->thread.acrs + offset) = tmp;\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\t*(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.fp_regs.fpc &&\n\t\t    (tmp & ~FPC_VALID_MASK) != 0)\n\t\t\t/* Invalid floating point control. */\n\t\t\treturn -EINVAL;\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\t*(__u32 *)((addr_t) &child->thread.fp_regs + offset) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure.\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.per_info;\n\t\t/*\n\t\t * This is magic. See per_struct and per_struct32.\n\t\t * By incident the offsets in per_struct are exactly\n\t\t * twice the offsets in per_struct32 for all fields.\n\t\t * The 8 byte fields need special handling though,\n\t\t * because the second half (bytes 4-7) is needed and\n\t\t * not the first half.\n\t\t */\n\t\tif ((offset >= (addr_t) &dummy_per32->control_regs &&\n\t\t     offset < (addr_t) (&dummy_per32->control_regs + 1)) ||\n\t\t    (offset >= (addr_t) &dummy_per32->starting_addr &&\n\t\t     offset <= (addr_t) &dummy_per32->ending_addr) ||\n\t\t    offset == (addr_t) &dummy_per32->lowcore.words.address)\n\t\t\toffset = offset*2 + 4;\n\t\telse\n\t\t\toffset = offset*2;\n\t\t*(__u32 *)((addr_t) &child->thread.per_info + offset) = tmp;\n\n\t}\n\n\tFixPerRegisters(child);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "3d6e48f43340343d97839eadb1ab7b6a3ea98797", "hash": 336645180341076785138852510297161990377, "size": 80, "message": "[S390] CVE-2008-1514: prevent ptrace padding area read/write in 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>"}
{"func": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask &&\n#ifdef CONFIG_COMPAT\n\t\t    data != PSW_MASK_MERGE(psw_user32_bits, data) &&\n#endif\n\t\t    data != PSW_MASK_MERGE(psw_user_bits, data))\n\t\t\t/* Invalid psw mask. */\n\t\t\treturn -EINVAL;\n#ifndef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.psw.addr)\n\t\t\t/* I'd like to reject addresses without the\n\t\t\t   high order bit but older gdb's rely on it */\n\t\t\tdata |= PSW_ADDR_AMODE;\n#endif\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc &&\n\t\t    (data & ~((unsigned long) FPC_VALID_MASK\n\t\t\t      << (BITS_PER_LONG - 32))) != 0)\n\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure \n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.per_info;\n\t\t*(addr_t *)((addr_t) &child->thread.per_info + offset) = data;\n\n\t}\n\n\tFixPerRegisters(child);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "3d6e48f43340343d97839eadb1ab7b6a3ea98797", "hash": 315587780023225026373961097981804672550, "size": 71, "message": "[S390] CVE-2008-1514: prevent ptrace padding area read/write in 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>"}
{"func": "static u32 __peek_user_compat(struct task_struct *child, addr_t addr)\n{\n\tstruct user32 *dummy32 = NULL;\n\tper_struct32 *dummy_per32 = NULL;\n\taddr_t offset;\n\t__u32 tmp;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t/* Fake a 31 bit psw mask. */\n\t\t\ttmp = (__u32)(task_pt_regs(child)->psw.mask >> 32);\n\t\t\ttmp = PSW32_MASK_MERGE(psw32_user_bits, tmp);\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Fake a 31 bit psw address. */\n\t\t\ttmp = (__u32) task_pt_regs(child)->psw.addr |\n\t\t\t\tPSW32_ADDR_AMODE31;\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\ttmp = *(__u32 *)((addr_t) &task_pt_regs(child)->psw +\n\t\t\t\t\t addr*2 + 4);\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\ttmp = *(__u32*)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = *(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4);\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\ttmp = *(__u32 *)((addr_t) &child->thread.fp_regs + offset);\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * per_info is found in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.per_info;\n\t\t/* This is magic. See per_struct and per_struct32. */\n\t\tif ((offset >= (addr_t) &dummy_per32->control_regs &&\n\t\t     offset < (addr_t) (&dummy_per32->control_regs + 1)) ||\n\t\t    (offset >= (addr_t) &dummy_per32->starting_addr &&\n\t\t     offset <= (addr_t) &dummy_per32->ending_addr) ||\n\t\t    offset == (addr_t) &dummy_per32->lowcore.words.address)\n\t\t\toffset = offset*2 + 4;\n\t\telse\n\t\t\toffset = offset*2;\n\t\ttmp = *(__u32 *)((addr_t) &child->thread.per_info + offset);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "3d6e48f43340343d97839eadb1ab7b6a3ea98797", "hash": 35699932838905238073673094450593528770, "size": 65, "message": "[S390] CVE-2008-1514: prevent ptrace padding area read/write in 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp://sources.redhat.com/cgi-bin/cvsweb.cgi/~checkout~/tests/ptrace-tests/tests/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) ./user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>"}
{"func": "int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\n{\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct *odn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tint error = 0;\n\n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\treturn 0;\n\t}\n\tif (!dir_notify_enable)\n\t\treturn -EINVAL;\n\tinode = filp->f_path.dentry->d_inode;\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn -ENOTDIR;\n\tdn = kmem_cache_alloc(dn_cache, GFP_KERNEL);\n\tif (dn == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&inode->i_lock);\n\tprev = &inode->i_dnotify;\n\twhile ((odn = *prev) != NULL) {\n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= arg;\n\t\t\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tprev = &odn->dn_next;\n\t}\n\n\terror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n\tif (error)\n\t\tgoto out_free;\n\n\tdn->dn_mask = arg;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\tdn->dn_next = inode->i_dnotify;\n\tinode->i_dnotify = dn;\n\tspin_unlock(&inode->i_lock);\n\n\tif (filp->f_op && filp->f_op->dir_notify)\n\t\treturn filp->f_op->dir_notify(filp, arg);\n\treturn 0;\n\nout_free:\n\tspin_unlock(&inode->i_lock);\n\tkmem_cache_free(dn_cache, dn);\n\treturn error;\n}", "target": 1, "cwe": ["CWE-362"], "project": "linux-2.6", "commit_id": "214b7049a7929f03bbd2786aaef04b8b79db34e2", "hash": 125123024928884710682759016236200663547, "size": 55, "message": "Fix dnotify/close race\n\nWe have a race between fcntl() and close() that can lead to\ndnotify_struct inserted into inode's list *after* the last descriptor\nhad been gone from current->files.\n\nSince that's the only point where dnotify_struct gets evicted, we are\nscrewed - it will stick around indefinitely.  Even after struct file in\nquestion is gone and freed.  Worse, we can trigger send_sigio() on it at\nany later point, which allows to send an arbitrary signal to arbitrary\nprocess if we manage to apply enough memory pressure to get the page\nthat used to host that struct file and fill it with the right pattern...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tunsigned long orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, timer->expires);\n\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\ttimer->expires = ktime_add_ns(timer->expires, incr * orun);\n\t\tif (timer->expires.tv64 > now.tv64)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\ttimer->expires = ktime_add(timer->expires, interval);\n\n\treturn orun;\n}", "target": 1, "cwe": ["CWE-189"], "project": "linux-2.6", "commit_id": "13788ccc41ceea5893f9c747c59bc0b28f2416c2", "hash": 179936784627311584747550933643377545966, "size": 30, "message": "[PATCH] hrtimer: prevent overrun DoS in hrtimer_forward()\n\nhrtimer_forward() does not check for the possible overflow of\ntimer->expires.  This can happen on 64 bit machines with large interval\nvalues and results currently in an endless loop in the softirq because the\nexpiry value becomes negative and therefor the timer is expired all the\ntime.\n\nCheck for this condition and set the expiry value to the max.  expiry time\nin the future.  The fix should be applied to stable kernel series as well.\n\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nAcked-by: Ingo Molnar <mingo@elte.hu>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "CairoFont *CairoFont::create(GfxFont *gfxFont, XRef *xref, FT_Library lib, GBool useCIDs) {\n  Ref embRef;\n  Object refObj, strObj;\n  GooString *tmpFileName, *fileName,*tmpFileName2;\n  DisplayFontParam *dfp;\n  FILE *tmpFile;\n  int c, i, n;\n  GfxFontType fontType;\n  char **enc;\n  char *name;\n  FoFiTrueType *ff;\n  FoFiType1C *ff1c;\n  Ref ref;\n  static cairo_user_data_key_t cairo_font_face_key;\n  cairo_font_face_t *cairo_font_face;\n  FT_Face face;\n\n  Gushort *codeToGID;\n  int codeToGIDLen;\n  \n  dfp = NULL;\n  codeToGID = NULL;\n  codeToGIDLen = 0;\n  cairo_font_face = NULL;\n  \n  ref = *gfxFont->getID();\n  fontType = gfxFont->getType();\n\n  tmpFileName = NULL;\n\n  if (gfxFont->getEmbeddedFontID(&embRef)) {\n    if (!openTempFile(&tmpFileName, &tmpFile, \"wb\", NULL)) {\n      error(-1, \"Couldn't create temporary font file\");\n      goto err2;\n    }\n    \n    refObj.initRef(embRef.num, embRef.gen);\n    refObj.fetch(xref, &strObj);\n    refObj.free();\n    strObj.streamReset();\n    while ((c = strObj.streamGetChar()) != EOF) {\n      fputc(c, tmpFile);\n    }\n    strObj.streamClose();\n    strObj.free();\n    fclose(tmpFile);\n    fileName = tmpFileName;\n    \n  } else if (!(fileName = gfxFont->getExtFontFile())) {\n    // look for a display font mapping or a substitute font\n    dfp = NULL;\n    if (gfxFont->getName()) {\n      dfp = globalParams->getDisplayFont(gfxFont);\n    }\n    if (!dfp) {\n      error(-1, \"Couldn't find a font for '%s'\",\n\t    gfxFont->getName() ? gfxFont->getName()->getCString()\n\t    : \"(unnamed)\");\n      goto err2;\n    }\n    switch (dfp->kind) {\n    case displayFontT1:\n      fileName = dfp->t1.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType0 : fontType1;\n      break;\n    case displayFontTT:\n      fileName = dfp->tt.fileName;\n      fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;\n      break;\n    }\n  }\n\n  switch (fontType) {\n  case fontType1:\n  case fontType1C:\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      error(-1, \"could not create type1 face\");\n      goto err2;\n    }\n    \n    enc = ((Gfx8BitFont *)gfxFont)->getEncoding();\n    \n    codeToGID = (Gushort *)gmallocn(256, sizeof(int));\n    codeToGIDLen = 256;\n    for (i = 0; i < 256; ++i) {\n      codeToGID[i] = 0;\n      if ((name = enc[i])) {\n\tcodeToGID[i] = (Gushort)FT_Get_Name_Index(face, name);\n      }\n    }\n    break;\n    \n  case fontCIDType2:\n    codeToGID = NULL;\n    n = 0;\n    if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {\n      n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();\n      if (n) {\n\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n\tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),\n\t\tn * sizeof(Gushort));\n      }\n    } else {\n      ff = FoFiTrueType::load(fileName->getCString());\n      if (! ff)\n\tgoto err2;\n      codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);\n      delete ff;\n    }\n    codeToGIDLen = n;\n    /* Fall through */\n  case fontTrueType:\n    if (!(ff = FoFiTrueType::load(fileName->getCString()))) {\n      error(-1, \"failed to load truetype font\\n\");\n      goto err2;\n    }\n    /* This might be set already for the CIDType2 case */\n    if (fontType == fontTrueType) {\n      codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);\n      codeToGIDLen = 256;\n    }\n    if (!openTempFile(&tmpFileName2, &tmpFile, \"wb\", NULL)) {\n      delete ff;\n      error(-1, \"failed to open truetype tempfile\\n\");\n      goto err2;\n    }\n    ff->writeTTF(&fileWrite, tmpFile);\n    fclose(tmpFile);\n    delete ff;\n\n    if (FT_New_Face(lib, tmpFileName2->getCString(), 0, &face)) {\n      error(-1, \"could not create truetype face\\n\");\n      goto err2;\n    }\n    unlink (tmpFileName2->getCString());\n    delete tmpFileName2;\n    break;\n    \n  case fontCIDType0:\n  case fontCIDType0C:\n\n    codeToGID = NULL;\n    codeToGIDLen = 0;\n\n    if (!useCIDs)\n    {\n      if ((ff1c = FoFiType1C::load(fileName->getCString()))) {\n        codeToGID = ff1c->getCIDToGIDMap(&codeToGIDLen);\n        delete ff1c;\n      }\n    }\n\n    if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n      gfree(codeToGID);\n      codeToGID = NULL;\n      error(-1, \"could not create cid face\\n\");\n      goto err2;\n    }\n    break;\n    \n  default:\n    printf (\"font type not handled\\n\");\n    goto err2;\n    break;\n  }\n\n  // delete the (temporary) font file -- with Unix hard link\n  // semantics, this will remove the last link; otherwise it will\n  // return an error, leaving the file to be deleted later\n  if (fileName == tmpFileName) {\n    unlink (fileName->getCString());\n    delete tmpFileName;\n  }\n\n  cairo_font_face = cairo_ft_font_face_create_for_ft_face (face,\n\t\t\t\t\t\t\t   FT_LOAD_NO_HINTING |\n\t\t\t\t\t\t\t   FT_LOAD_NO_BITMAP);\n  if (cairo_font_face == NULL) {\n    error(-1, \"could not create cairo font\\n\");\n    goto err2; /* this doesn't do anything, but it looks like we're\n\t\t* handling the error */\n  } {\n  CairoFont *ret = new CairoFont(ref, cairo_font_face, face, codeToGID, codeToGIDLen);\n  cairo_font_face_set_user_data (cairo_font_face, \n\t\t\t\t &cairo_font_face_key,\n\t\t\t\t ret,\n\t\t\t\t cairo_font_face_destroy);\n\n  return ret;\n  }\n err2:\n  /* hmm? */\n  printf (\"some font thing failed\\n\");\n  return NULL;\n}", "target": 1, "cwe": ["CWE-20"], "project": "poppler", "commit_id": "1a531dcfee1c6fc79a414c38cbe7327fbf9a59d8", "hash": 294666036737394333902439398055542844956, "size": 195, "message": "Fix a crash with invalid embedded fonts"}
{"func": "m4_mkstemp (struct obstack *obs, int argc, token_data **argv)\n{\n  if (bad_argc (argv[0], argc, 2, 2))\n    return;\n  mkstemp_helper (obs, ARG (1));\n}", "target": 1, "cwe": [], "project": "m4", "commit_id": "5345bb49077bfda9fabd048e563f9e7077fe335d", "hash": 318397935641703007412587121061184802559, "size": 6, "message": "Minor security fix: Quote output of mkstemp.\n\n* src/builtin.c (mkstemp_helper): Produce quoted output.\n* doc/m4.texinfo (Mkstemp): Update the documentation and tests.\n* NEWS: Document this change.\n\nSigned-off-by: Eric Blake <ebb9@byu.net>\n(cherry picked from commit bd9900d65eb9cd5add0f107e94b513fa267495ba)"}
{"func": "mkstemp_helper (struct obstack *obs, const char *name)\n{\n  int fd;\n  int len;\n  int i;\n\n  /* Guarantee that there are six trailing 'X' characters, even if the\n     user forgot to supply them.  */\n  len = strlen (name);\n  obstack_grow (obs, name, len);\n  for (i = 0; len > 0 && i < 6; i++)\n    if (name[--len] != 'X')\n      break;\n  for (; i < 6; i++)\n    obstack_1grow (obs, 'X');\n  obstack_1grow (obs, '\\0');\n\n  errno = 0;\n  fd = mkstemp ((char *) obstack_base (obs));\n  if (fd < 0)\n    {\n      M4ERROR ((0, errno, \"cannot create tempfile `%s'\", name));\n      obstack_free (obs, obstack_finish (obs));\n    }\n  else\n    close (fd);\n}", "target": 1, "cwe": [], "project": "m4", "commit_id": "5345bb49077bfda9fabd048e563f9e7077fe335d", "hash": 323725070097395571956742448608555080438, "size": 27, "message": "Minor security fix: Quote output of mkstemp.\n\n* src/builtin.c (mkstemp_helper): Produce quoted output.\n* doc/m4.texinfo (Mkstemp): Update the documentation and tests.\n* NEWS: Document this change.\n\nSigned-off-by: Eric Blake <ebb9@byu.net>\n(cherry picked from commit bd9900d65eb9cd5add0f107e94b513fa267495ba)"}
{"func": "m4_maketemp (struct obstack *obs, int argc, token_data **argv)\n{\n  if (bad_argc (argv[0], argc, 2, 2))\n    return;\n  if (no_gnu_extensions)\n    {\n      /* POSIX states \"any trailing 'X' characters [are] replaced with\n\t the current process ID as a string\", without referencing the\n\t file system.  Horribly insecure, but we have to do it when we\n\t are in traditional mode.\n\n\t For reference, Solaris m4 does:\n\t   maketemp() -> `'\n\t   maketemp(X) -> `X'\n\t   maketemp(XX) -> `Xn', where n is last digit of pid\n\t   maketemp(XXXXXXXX) -> `X00nnnnn', where nnnnn is 16-bit pid\n      */\n      const char *str = ARG (1);\n      int len = strlen (str);\n      int i;\n      int len2;\n\n      M4ERROR ((warning_status, 0, \"recommend using mkstemp instead\"));\n      for (i = len; i > 1; i--)\n\tif (str[i - 1] != 'X')\n\t  break;\n      obstack_grow (obs, str, i);\n      str = ntoa ((int32_t) getpid (), 10);\n      len2 = strlen (str);\n      if (len2 > len - i)\n\tobstack_grow0 (obs, str + len2 - (len - i), len - i);\n      else\n\t{\n\t  while (i++ < len - len2)\n\t    obstack_1grow (obs, '0');\n\t  obstack_grow0 (obs, str, len2);\n\t}\n    }\n  else\n    mkstemp_helper (obs, ARG (1));\n}", "target": 1, "cwe": [], "project": "m4", "commit_id": "5345bb49077bfda9fabd048e563f9e7077fe335d", "hash": 14712089961255949909474829467913790190, "size": 41, "message": "Minor security fix: Quote output of mkstemp.\n\n* src/builtin.c (mkstemp_helper): Produce quoted output.\n* doc/m4.texinfo (Mkstemp): Update the documentation and tests.\n* NEWS: Document this change.\n\nSigned-off-by: Eric Blake <ebb9@byu.net>\n(cherry picked from commit bd9900d65eb9cd5add0f107e94b513fa267495ba)"}
{"func": "produce_frozen_state (const char *name)\n{\n  FILE *file;\n  int h;\n  symbol *sym;\n  const builtin *bp;\n\n  if (file = fopen (name, O_BINARY ? \"wb\" : \"w\"), !file)\n    {\n      M4ERROR ((warning_status, errno, name));\n      return;\n    }\n\n  /* Write a recognizable header.  */\n\n  xfprintf (file, \"# This is a frozen state file generated by %s\\n\",\n\t   PACKAGE_STRING);\n  xfprintf (file, \"V1\\n\");\n\n  /* Dump quote delimiters.  */\n\n  if (strcmp (lquote.string, DEF_LQUOTE) || strcmp (rquote.string, DEF_RQUOTE))\n    {\n      xfprintf (file, \"Q%d,%d\\n\", (int) lquote.length, (int) rquote.length);\n      fputs (lquote.string, file);\n      fputs (rquote.string, file);\n      fputc ('\\n', file);\n    }\n\n  /* Dump comment delimiters.  */\n\n  if (strcmp (bcomm.string, DEF_BCOMM) || strcmp (ecomm.string, DEF_ECOMM))\n    {\n      xfprintf (file, \"C%d,%d\\n\", (int) bcomm.length, (int) ecomm.length);\n      fputs (bcomm.string, file);\n      fputs (ecomm.string, file);\n      fputc ('\\n', file);\n    }\n\n  /* Dump all symbols.  */\n\n  for (h = 0; h < hash_table_size; h++)\n    {\n\n      /* Process all entries in one bucket, from the last to the first.\n\t This order ensures that, at reload time, pushdef's will be\n\t executed with the oldest definitions first.  */\n\n      symtab[h] = reverse_symbol_list (symtab[h]);\n      for (sym = symtab[h]; sym; sym = SYMBOL_NEXT (sym))\n\t{\n\t  switch (SYMBOL_TYPE (sym))\n\t    {\n\t    case TOKEN_TEXT:\n\t      xfprintf (file, \"T%d,%d\\n\",\n\t\t\t(int) strlen (SYMBOL_NAME (sym)),\n\t\t\t(int) strlen (SYMBOL_TEXT (sym)));\n\t      fputs (SYMBOL_NAME (sym), file);\n\t      fputs (SYMBOL_TEXT (sym), file);\n\t      fputc ('\\n', file);\n\t      break;\n\n\t    case TOKEN_FUNC:\n\t      bp = find_builtin_by_addr (SYMBOL_FUNC (sym));\n\t      if (bp == NULL)\n\t\t{\n\t\t  M4ERROR ((warning_status, 0, \"\\\nINTERNAL ERROR: builtin not found in builtin table!\"));\n\t\t  abort ();\n\t\t}\n\t      xfprintf (file, \"F%d,%d\\n\",\n\t\t\t(int) strlen (SYMBOL_NAME (sym)),\n\t\t\t(int) strlen (bp->name));\n\t      fputs (SYMBOL_NAME (sym), file);\n\t      fputs (bp->name, file);\n\t      fputc ('\\n', file);\n\t      break;\n\n\t    case TOKEN_VOID:\n\t      /* Ignore placeholder tokens that exist due to traceon.  */\n\t      break;\n\n\t    default:\n\t      M4ERROR ((warning_status, 0, \"\\\nINTERNAL ERROR: bad token data type in freeze_one_symbol ()\"));\n\t      abort ();\n\t      break;\n\t    }\n\t}\n\n      /* Reverse the bucket once more, putting it back as it was.  */\n\n      symtab[h] = reverse_symbol_list (symtab[h]);\n    }\n\n  /* Let diversions be issued from output.c module, its cleaner to have this\n     piece of code there.  */\n\n  freeze_diversions (file);\n\n  /* All done.  */\n\n  fputs (\"# End of frozen state file\\n\", file);\n  if (close_stream (file) != 0)\n    M4ERROR ((EXIT_FAILURE, errno, \"unable to create frozen state\"));\n}", "target": 1, "cwe": [], "project": "m4", "commit_id": "035998112737e52cb229e342913ef404e5a51040", "hash": 263127698236721605389098427202622408056, "size": 106, "message": "Security fix: avoid arbitrary code execution with 'm4 -F'.\n\n* src/freeze.c (produce_frozen_state): Never pass raw file name as\nprintf format.\n* NEWS: Document this fix.\n\nSigned-off-by: Eric Blake <ebb9@byu.net>\n(cherry picked from commit 031a71a80442ed2ad3c2ee14d5811c786a12c51b)"}
{"func": "static unsigned char asn1_oid_decode(struct asn1_ctx *ctx,\n\t\t\t\t     unsigned char *eoc,\n\t\t\t\t     unsigned long **oid,\n\t\t\t\t     unsigned int *len)\n{\n\tunsigned long subid;\n\tunsigned int  size;\n\tunsigned long *optr;\n\n\tsize = eoc - ctx->pointer + 1;\n\t*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\n\tif (*oid == NULL) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(\"OOM in bsalg (%d)\\n\", __LINE__);\n\t\treturn 0;\n\t}\n\n\toptr = *oid;\n\n\tif (!asn1_subid_decode(ctx, &subid)) {\n\t\tkfree(*oid);\n\t\t*oid = NULL;\n\t\treturn 0;\n\t}\n\n\tif (subid < 40) {\n\t\toptr [0] = 0;\n\t\toptr [1] = subid;\n\t} else if (subid < 80) {\n\t\toptr [0] = 1;\n\t\toptr [1] = subid - 40;\n\t} else {\n\t\toptr [0] = 2;\n\t\toptr [1] = subid - 80;\n\t}\n\n\t*len = 2;\n\toptr += 2;\n\n\twhile (ctx->pointer < eoc) {\n\t\tif (++(*len) > size) {\n\t\t\tctx->error = ASN1_ERR_DEC_BADVALUE;\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!asn1_subid_decode(ctx, optr++)) {\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5", "hash": 258736852088289996589788699342684506403, "size": 55, "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "asn1_oid_decode(struct asn1_ctx *ctx,\n\t\tunsigned char *eoc, unsigned long **oid, unsigned int *len)\n{\n\tunsigned long subid;\n\tunsigned int size;\n\tunsigned long *optr;\n\n\tsize = eoc - ctx->pointer + 1;\n\t*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);\n\tif (*oid == NULL)\n\t\treturn 0;\n\n\toptr = *oid;\n\n\tif (!asn1_subid_decode(ctx, &subid)) {\n\t\tkfree(*oid);\n\t\t*oid = NULL;\n\t\treturn 0;\n\t}\n\n\tif (subid < 40) {\n\t\toptr[0] = 0;\n\t\toptr[1] = subid;\n\t} else if (subid < 80) {\n\t\toptr[0] = 1;\n\t\toptr[1] = subid - 40;\n\t} else {\n\t\toptr[0] = 2;\n\t\toptr[1] = subid - 80;\n\t}\n\n\t*len = 2;\n\toptr += 2;\n\n\twhile (ctx->pointer < eoc) {\n\t\tif (++(*len) > size) {\n\t\t\tctx->error = ASN1_ERR_DEC_BADVALUE;\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!asn1_subid_decode(ctx, optr++)) {\n\t\t\tkfree(*oid);\n\t\t\t*oid = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5", "hash": 24934009460877332029578215926851751208, "size": 50, "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "asn1_header_decode(struct asn1_ctx *ctx,\n\t\t   unsigned char **eoc,\n\t\t   unsigned int *cls, unsigned int *con, unsigned int *tag)\n{\n\tunsigned int def = 0;\n\tunsigned int len = 0;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5", "hash": 100827339625052954108223001238225390166, "size": 19, "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static unsigned char asn1_header_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned char **eoc,\n\t\t\t\t\tunsigned int *cls,\n\t\t\t\t\tunsigned int *con,\n\t\t\t\t\tunsigned int *tag)\n{\n\tunsigned int def, len;\n\n\tif (!asn1_id_decode(ctx, cls, con, tag))\n\t\treturn 0;\n\n\tdef = len = 0;\n\tif (!asn1_length_decode(ctx, &def, &len))\n\t\treturn 0;\n\n\tif (def)\n\t\t*eoc = ctx->pointer + len;\n\telse\n\t\t*eoc = NULL;\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5", "hash": 228756596288618045464924038405659988128, "size": 21, "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static unsigned char asn1_length_decode(struct asn1_ctx *ctx,\n\t\t\t\t\tunsigned int *def,\n\t\t\t\t\tunsigned int *len)\n{\n\tunsigned char ch, cnt;\n\n\tif (!asn1_octet_decode(ctx, &ch))\n\t\treturn 0;\n\n\tif (ch == 0x80)\n\t\t*def = 0;\n\telse {\n\t\t*def = 1;\n\n\t\tif (ch < 0x80)\n\t\t\t*len = ch;\n\t\telse {\n\t\t\tcnt = ch & 0x7F;\n\t\t\t*len = 0;\n\n\t\t\twhile (cnt > 0) {\n\t\t\t\tif (!asn1_octet_decode(ctx, &ch))\n\t\t\t\t\treturn 0;\n\t\t\t\t*len <<= 8;\n\t\t\t\t*len |= ch;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5", "hash": 214953782388236534754341406713123646165, "size": 31, "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "asn1_length_decode(struct asn1_ctx *ctx, unsigned int *def, unsigned int *len)\n{\n\tunsigned char ch, cnt;\n\n\tif (!asn1_octet_decode(ctx, &ch))\n\t\treturn 0;\n\n\tif (ch == 0x80)\n\t\t*def = 0;\n\telse {\n\t\t*def = 1;\n\n\t\tif (ch < 0x80)\n\t\t\t*len = ch;\n\t\telse {\n\t\t\tcnt = (unsigned char) (ch & 0x7F);\n\t\t\t*len = 0;\n\n\t\t\twhile (cnt > 0) {\n\t\t\t\tif (!asn1_octet_decode(ctx, &ch))\n\t\t\t\t\treturn 0;\n\t\t\t\t*len <<= 8;\n\t\t\t\t*len |= ch;\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1, "cwe": ["CWE-119"], "project": "linux-2.6", "commit_id": "ddb2c43594f22843e9f3153da151deaba1a834c5", "hash": 188088692906320605891566647399338031473, "size": 29, "message": "asn1: additional sanity checking during BER decoding\n\n- Don't trust a length which is greater than the working buffer.\n  An invalid length could cause overflow when calculating buffer size\n  for decoding oid.\n\n- An oid length of zero is invalid and allows for an off-by-one error when\n  decoding oid because the first subid actually encodes first 2 subids.\n\n- A primitive encoding may not have an indefinite length.\n\nThanks to Wei Wang from McAfee for report.\n\nCc: Steven French <sfrench@us.ibm.com>\nCc: stable@kernel.org\nAcked-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: Chris Wright <chrisw@sous-sol.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\n\tiph = ip_hdr(skb);\n\n\tread_lock(&ipip6_lock);\n\tif ((tunnel = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->stat.rx_errors++;\n\t\t\tread_unlock(&ipip6_lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->stat.rx_packets++;\n\t\ttunnel->stat.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tdst_release(skb->dst);\n\t\tskb->dst = NULL;\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\tread_unlock(&ipip6_lock);\n\t\treturn 0;\n\t}\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\tkfree_skb(skb);\n\tread_unlock(&ipip6_lock);\nout:\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-399"], "project": "linux-2.6", "commit_id": "36ca34cc3b8335eb1fe8bd9a1d0a2592980c3f02", "hash": 33362704464284364551880964600617727631, "size": 45, "message": "sit: Add missing kfree_skb() on pskb_may_pull() failure.\n\nNoticed by Paul Marks <paul@pmarks.net>.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>"}
{"func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running);\n\n\tslice *= se->load.weight;\n\tdo_div(slice, cfs_rq->load.weight);\n\n\treturn slice;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "6a6029b8cefe0ca7e82f27f3904dbedba3de4e06", "hash": 58865871396891118754639920075524021506, "size": 9, "message": "sched: simplify sched_slice()\n\nUse the existing calc_delta_mine() calculation for sched_slice(). This\nsaves a divide and simplifies the code because we share it with the\nother /cfs_rq->load users.\n\nIt also improves code size:\n\n      text    data     bss     dec     hex filename\n     42659    2740     144   45543    b1e7 sched.o.before\n     42093    2740     144   44977    afb1 sched.o.after\n\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>"}
{"func": "static u64 sched_vslice_add(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn __sched_vslice(cfs_rq->load.weight + se->load.weight,\n\t\t\tcfs_rq->nr_running + 1);\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "ac884dec6d4a7df252150af875cffddf8f1d9c15", "hash": 22178641074713844516345826435813180596, "size": 5, "message": "sched: fair-group scheduling vs latency\n\nCurrently FAIR_GROUP sched grows the scheduler latency outside of\nsysctl_sched_latency, invert this so it stays within.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static u64 __sched_vslice(unsigned long rq_weight, unsigned long nr_running)\n{\n\tu64 vslice = __sched_period(nr_running);\n\n\tvslice *= NICE_0_LOAD;\n\tdo_div(vslice, rq_weight);\n\n\treturn vslice;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "ac884dec6d4a7df252150af875cffddf8f1d9c15", "hash": 26078873616473646001296634476156282378, "size": 9, "message": "sched: fair-group scheduling vs latency\n\nCurrently FAIR_GROUP sched grows the scheduler latency outside of\nsysctl_sched_latency, invert this so it stays within.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn calc_delta_mine(__sched_period(cfs_rq->nr_running),\n\t\t\t       se->load.weight, &cfs_rq->load);\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "ac884dec6d4a7df252150af875cffddf8f1d9c15", "hash": 242984434542507599503181154553976580439, "size": 5, "message": "sched: fair-group scheduling vs latency\n\nCurrently FAIR_GROUP sched grows the scheduler latency outside of\nsysctl_sched_latency, invert this so it stays within.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static u64 sched_vslice_add(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tunsigned long nr_running = cfs_rq->nr_running;\n\tunsigned long weight;\n\tu64 vslice;\n\n\tif (!se->on_rq)\n\t\tnr_running++;\n\n\tvslice = __sched_period(nr_running);\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tweight = cfs_rq->load.weight;\n\t\tif (!se->on_rq)\n\t\t\tweight += se->load.weight;\n\n\t\tvslice *= NICE_0_LOAD;\n\t\tdo_div(vslice, weight);\n\t}\n\n\treturn vslice;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "8f1bc385cfbab474db6c27b5af1e439614f3025c", "hash": 199943656571357591846689473102776500500, "size": 24, "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static unsigned long wakeup_gran(struct sched_entity *se)\n{\n\tunsigned long gran = sysctl_sched_wakeup_granularity;\n\n\t/*\n\t * More easily preempt - nice tasks, while not making\n\t * it harder for + nice tasks.\n\t */\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\n\treturn gran;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "8f1bc385cfbab474db6c27b5af1e439614f3025c", "hash": 314868220618263729085248506628771974784, "size": 13, "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running);\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tslice *= se->load.weight;\n\t\tdo_div(slice, cfs_rq->load.weight);\n\t}\n\n\n\treturn slice;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "8f1bc385cfbab474db6c27b5af1e439614f3025c", "hash": 20493139195104024011277989870755546981, "size": 14, "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "calc_delta_fair(unsigned long delta_exec, struct load_weight *lw)\n{\n\treturn calc_delta_mine(delta_exec, NICE_0_LOAD, lw);\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "8f1bc385cfbab474db6c27b5af1e439614f3025c", "hash": 275354062946871065189509316823270452840, "size": 4, "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)\n{\n\tu64 vruntime;\n\n\tif (first_fair(cfs_rq)) {\n\t\tvruntime = min_vruntime(cfs_rq->min_vruntime,\n\t\t\t\t__pick_next_entity(cfs_rq)->vruntime);\n\t} else\n\t\tvruntime = cfs_rq->min_vruntime;\n\n\t/*\n\t * The 'current' period is already promised to the current tasks,\n\t * however the extra weight of the new task will slow them down a\n\t * little, place the new task so that it fits in the slot that\n\t * stays open at the end.\n\t */\n\tif (initial && sched_feat(START_DEBIT))\n\t\tvruntime += sched_vslice_add(cfs_rq, se);\n\n\tif (!initial) {\n\t\t/* sleeps upto a single latency don't count. */\n\t\tif (sched_feat(NEW_FAIR_SLEEPERS)) {\n\t\t\tif (sched_feat(NORMALIZED_SLEEPER))\n\t\t\t\tvruntime -= calc_delta_fair(sysctl_sched_latency,\n\t\t\t\t\t\t&cfs_rq->load);\n\t\t\telse\n\t\t\t\tvruntime -= sysctl_sched_latency;\n\t\t}\n\n\t\t/* ensure we never gain time by being placed backwards. */\n\t\tvruntime = max_vruntime(se->vruntime, vruntime);\n\t}\n\n\tse->vruntime = vruntime;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "8f1bc385cfbab474db6c27b5af1e439614f3025c", "hash": 308682937641422833765183420086525125925, "size": 35, "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,\n\t      unsigned long delta_exec)\n{\n\tunsigned long delta_exec_weighted;\n\n\tschedstat_set(curr->exec_max, max((u64)delta_exec, curr->exec_max));\n\n\tcurr->sum_exec_runtime += delta_exec;\n\tschedstat_add(cfs_rq, exec_clock, delta_exec);\n\tdelta_exec_weighted = delta_exec;\n\tif (unlikely(curr->load.weight != NICE_0_LOAD)) {\n\t\tdelta_exec_weighted = calc_delta_fair(delta_exec_weighted,\n\t\t\t\t\t\t\t&curr->load);\n\t}\n\tcurr->vruntime += delta_exec_weighted;\n}", "target": 1, "cwe": [], "project": "linux-2.6", "commit_id": "8f1bc385cfbab474db6c27b5af1e439614f3025c", "hash": 65520173795750994905270968391954591377, "size": 16, "message": "sched: fair: weight calculations\n\nIn order to level the hierarchy, we need to calculate load based on the\nroot view. That is, each task's load is in the same unit.\n\n             A\n            / \\\n           B   1\n          / \\\n         2   3\n\nTo compute 1's load we do:\n\n\t   weight(1)\n\t--------------\n\t rq_weight(A)\n\nTo compute 2's load we do:\n\n\t  weight(2)      weight(B)\n\t------------ * -----------\n\trq_weight(B)   rw_weight(A)\n\nThis yields load fractions in comparable units.\n\nThe consequence is that it changes virtual time. We used to have:\n\n                time_{i}\n  vtime_{i} = ------------\n               weight_{i}\n\n  vtime = \\Sum vtime_{i} = time / rq_weight.\n\nBut with the new way of load calculation we get that vtime equals time.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>"}
{"func": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n\n      if (len != data_size)\n\t{\n\t  /* This is unexpected packet length, but\n\t   * just ignore it, for now.\n\t   */\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n\n      p = data + 2;\n\n      /* Count all server_names in the packet. */\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\n\t  p += len;\n\t}\n\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t/* no names found */\n\n      /* we cannot accept more server names.\n       */\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  switch (type)\n\t    {\n\t    case 0:\t\t/* NAME_DNS */\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* move to next record */\n\t  p += len;\n\t}\n    }\n  return 0;\n}", "target": 1, "cwe": ["CWE-189"], "project": "gnutls", "commit_id": "bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "hash": 168266384151590392485061020862846264327, "size": 81, "message": "Fix GNUTLS-SA-2008-1 security vulnerabilities.\nSee http://www.gnu.org/software/gnutls/security.html for updates."}
{"func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      length = ciphertext.size - hash_size - pad;\n\n      if (pad > ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-189"], "project": "gnutls", "commit_id": "bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "hash": 137431019550729333496535558945842202837, "size": 167, "message": "Fix GNUTLS-SA-2008-1 security vulnerabilities.\nSee http://www.gnu.org/software/gnutls/security.html for updates."}
{"func": "_gnutls_recv_handshake_header (gnutls_session_t session,\n\t\t\t       gnutls_handshake_description_t type,\n\t\t\t       gnutls_handshake_description_t * recv_type)\n{\n  int ret;\n  uint32_t length32 = 0;\n  uint8_t *dataptr = NULL;\t/* for realloc */\n  size_t handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n  /* if we have data into the buffer then return them, do not read the next packet.\n   * In order to return we need a full TLS handshake header, or in case of a version 2\n   * packet, then we return the first byte.\n   */\n  if (session->internals.handshake_header_buffer.header_size ==\n      handshake_header_size || (session->internals.v2_hello != 0\n\t\t\t\t&& type == GNUTLS_HANDSHAKE_CLIENT_HELLO\n\t\t\t\t&& session->internals.\n\t\t\t\thandshake_header_buffer.packet_length > 0))\n    {\n\n      *recv_type = session->internals.handshake_header_buffer.recv_type;\n\n      return session->internals.handshake_header_buffer.packet_length;\n    }\n\n  /* Note: SSL2_HEADERS == 1 */\n\n  dataptr = session->internals.handshake_header_buffer.header;\n\n  /* If we haven't already read the handshake headers.\n   */\n  if (session->internals.handshake_header_buffer.header_size < SSL2_HEADERS)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type, dataptr, SSL2_HEADERS);\n\n      if (ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* The case ret==0 is caught here.\n       */\n      if (ret != SSL2_HEADERS)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      session->internals.handshake_header_buffer.header_size = SSL2_HEADERS;\n    }\n\n  if (session->internals.v2_hello == 0\n      || type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type,\n\t\t\t\t       &dataptr[session->\n\t\t\t\t\t\tinternals.\n\t\t\t\t\t\thandshake_header_buffer.\n\t\t\t\t\t\theader_size],\n\t\t\t\t       HANDSHAKE_HEADER_SIZE -\n\t\t\t\t       session->internals.\n\t\t\t\t       handshake_header_buffer.header_size);\n      if (ret <= 0)\n\t{\n\t  gnutls_assert ();\n\t  return (ret < 0) ? ret : GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      if ((size_t) ret !=\n\t  HANDSHAKE_HEADER_SIZE -\n\t  session->internals.handshake_header_buffer.header_size)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      *recv_type = dataptr[0];\n\n      /* we do not use DECR_LEN because we know\n       * that the packet has enough data.\n       */\n      length32 = _gnutls_read_uint24 (&dataptr[1]);\n      handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n      _gnutls_handshake_log (\"HSK[%x]: %s was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (dataptr[0]),\n\t\t\t     length32 + HANDSHAKE_HEADER_SIZE);\n\n    }\n  else\n    {\t\t\t\t/* v2 hello */\n      length32 = session->internals.v2_hello - SSL2_HEADERS;\t/* we've read the first byte */\n\n      handshake_header_size = SSL2_HEADERS;\t/* we've already read one byte */\n\n      *recv_type = dataptr[0];\n\n      _gnutls_handshake_log (\"HSK[%x]: %s(v2) was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (*recv_type),\n\t\t\t     length32 + handshake_header_size);\n\n      if (*recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n\t{\t\t\t/* it should be one or nothing */\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n    }\n\n  /* put the packet into the buffer */\n  session->internals.handshake_header_buffer.header_size =\n    handshake_header_size;\n  session->internals.handshake_header_buffer.packet_length = length32;\n  session->internals.handshake_header_buffer.recv_type = *recv_type;\n\n  if (*recv_type != type)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n    }\n\n  return length32;\n}", "target": 1, "cwe": ["CWE-189"], "project": "gnutls", "commit_id": "bc8102405fda11ea00ca3b42acc4f4bce9d6e97b", "hash": 205220500280194884766195233361120369735, "size": 124, "message": "Fix GNUTLS-SA-2008-1 security vulnerabilities.\nSee http://www.gnu.org/software/gnutls/security.html for updates."}
{"func": "_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (ciphertext.size < (unsigned) blocksize + hash_size)\n    {\n      _gnutls_record_log\n\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n\t session, ciphertext.size, blocksize, hash_size);\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      if ((int)pad > (int)ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}", "target": 1, "cwe": ["CWE-189"], "project": "gnutls", "commit_id": "d223040e498bd50a4b9e0aa493e78587ae1ed653", "hash": 133466176970244054302162994213823627570, "size": 175, "message": "Fix broken debug check for GNUTLS-SA-2008-1."}
{"func": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int len, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint i;\n\tunsigned int vm_flags;\n\n\tif (len <= 0)\n\t\treturn 0;\n\t/* \n\t * Require read or write permissions.\n\t * If 'force' is set, we only require the \"MAY\" flags.\n\t */\n\tvm_flags  = write ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);\n\tvm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);\n\ti = 0;\n\n\tdo {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned int foll_flags;\n\n\t\tvma = find_extend_vma(mm, start);\n\t\tif (!vma && in_gate_area(tsk, start)) {\n\t\t\tunsigned long pg = start & PAGE_MASK;\n\t\t\tstruct vm_area_struct *gate_vma = get_gate_vma(tsk);\n\t\t\tpgd_t *pgd;\n\t\t\tpud_t *pud;\n\t\t\tpmd_t *pmd;\n\t\t\tpte_t *pte;\n\t\t\tif (write) /* user gate pages are read-only */\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tif (pg > TASK_SIZE)\n\t\t\t\tpgd = pgd_offset_k(pg);\n\t\t\telse\n\t\t\t\tpgd = pgd_offset_gate(mm, pg);\n\t\t\tBUG_ON(pgd_none(*pgd));\n\t\t\tpud = pud_offset(pgd, pg);\n\t\t\tBUG_ON(pud_none(*pud));\n\t\t\tpmd = pmd_offset(pud, pg);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\tpte = pte_offset_map(pmd, pg);\n\t\t\tif (pte_none(*pte)) {\n\t\t\t\tpte_unmap(pte);\n\t\t\t\treturn i ? : -EFAULT;\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tstruct page *page = vm_normal_page(gate_vma, start, *pte);\n\t\t\t\tpages[i] = page;\n\t\t\t\tif (page)\n\t\t\t\t\tget_page(page);\n\t\t\t}\n\t\t\tpte_unmap(pte);\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = gate_vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vma || (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\t\t|| !(vm_flags & vma->vm_flags))\n\t\t\treturn i ? : -EFAULT;\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &len, i, write);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfoll_flags = FOLL_TOUCH;\n\t\tif (pages)\n\t\t\tfoll_flags |= FOLL_GET;\n\t\tif (!write && !(vma->vm_flags & VM_LOCKED) &&\n\t\t    (!vma->vm_ops || !vma->vm_ops->fault))\n\t\t\tfoll_flags |= FOLL_ANON;\n\n\t\tdo {\n\t\t\tstruct page *page;\n\n\t\t\t/*\n\t\t\t * If tsk is ooming, cut off its access to large memory\n\t\t\t * allocations. It has a pending SIGKILL, but it can't\n\t\t\t * be processed until returning to user space.\n\t\t\t */\n\t\t\tif (unlikely(test_tsk_thread_flag(tsk, TIF_MEMDIE)))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (write)\n\t\t\t\tfoll_flags |= FOLL_WRITE;\n\n\t\t\tcond_resched();\n\t\t\twhile (!(page = follow_page(vma, start, foll_flags))) {\n\t\t\t\tint ret;\n\t\t\t\tret = handle_mm_fault(mm, vma, start,\n\t\t\t\t\t\tfoll_flags & FOLL_WRITE);\n\t\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\t\tif (ret & VM_FAULT_OOM)\n\t\t\t\t\t\treturn i ? i : -ENOMEM;\n\t\t\t\t\telse if (ret & VM_FAULT_SIGBUS)\n\t\t\t\t\t\treturn i ? i : -EFAULT;\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\t\t\ttsk->maj_flt++;\n\t\t\t\telse\n\t\t\t\t\ttsk->min_flt++;\n\n\t\t\t\t/*\n\t\t\t\t * The VM_FAULT_WRITE bit tells us that\n\t\t\t\t * do_wp_page has broken COW when necessary,\n\t\t\t\t * even if maybe_mkwrite decided not to set\n\t\t\t\t * pte_write. We can thus safely do subsequent\n\t\t\t\t * page lookups as if they were reads.\n\t\t\t\t */\n\t\t\t\tif (ret & VM_FAULT_WRITE)\n\t\t\t\t\tfoll_flags &= ~FOLL_WRITE;\n\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t\tif (pages) {\n\t\t\t\tpages[i] = page;\n\n\t\t\t\tflush_anon_page(vma, page, start);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tif (vmas)\n\t\t\t\tvmas[i] = vma;\n\t\t\ti++;\n\t\t\tstart += PAGE_SIZE;\n\t\t\tlen--;\n\t\t} while (len && start < vma->vm_end);\n\t} while (len);\n\treturn i;\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f", "hash": 192373302205049669343839180384526250684, "size": 136, "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int do_pages_stat(struct mm_struct *mm, struct page_to_node *pm)\n{\n\tdown_read(&mm->mmap_sem);\n\n\tfor ( ; pm->node != MAX_NUMNODES; pm++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err;\n\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pm->addr);\n\t\tif (!vma)\n\t\t\tgoto set_status;\n\n\t\tpage = follow_page(vma, pm->addr, 0);\n\t\terr = -ENOENT;\n\t\t/* Use PageReserved to check for zero page */\n\t\tif (!page || PageReserved(page))\n\t\t\tgoto set_status;\n\n\t\terr = page_to_nid(page);\nset_status:\n\t\tpm->status = err;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\treturn 0;\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f", "hash": 190691605824195418496832518891413550081, "size": 28, "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static int do_move_pages(struct mm_struct *mm, struct page_to_node *pm,\n\t\t\t\tint migrate_all)\n{\n\tint err;\n\tstruct page_to_node *pp;\n\tLIST_HEAD(pagelist);\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Build a list of pages to migrate\n\t */\n\tmigrate_prep();\n\tfor (pp = pm; pp->node != MAX_NUMNODES; pp++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * A valid page pointer that will not match any of the\n\t\t * pages that will be moved.\n\t\t */\n\t\tpp->page = ZERO_PAGE(0);\n\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pp->addr);\n\t\tif (!vma || !vma_migratable(vma))\n\t\t\tgoto set_status;\n\n\t\tpage = follow_page(vma, pp->addr, FOLL_GET);\n\t\terr = -ENOENT;\n\t\tif (!page)\n\t\t\tgoto set_status;\n\n\t\tif (PageReserved(page))\t\t/* Check for zero page */\n\t\t\tgoto put_and_set;\n\n\t\tpp->page = page;\n\t\terr = page_to_nid(page);\n\n\t\tif (err == pp->node)\n\t\t\t/*\n\t\t\t * Node already in the right place\n\t\t\t */\n\t\t\tgoto put_and_set;\n\n\t\terr = -EACCES;\n\t\tif (page_mapcount(page) > 1 &&\n\t\t\t\t!migrate_all)\n\t\t\tgoto put_and_set;\n\n\t\terr = isolate_lru_page(page, &pagelist);\nput_and_set:\n\t\t/*\n\t\t * Either remove the duplicate refcount from\n\t\t * isolate_lru_page() or drop the page ref if it was\n\t\t * not isolated.\n\t\t */\n\t\tput_page(page);\nset_status:\n\t\tpp->status = err;\n\t}\n\n\tif (!list_empty(&pagelist))\n\t\terr = migrate_pages(&pagelist, new_page_node,\n\t\t\t\t(unsigned long)pm);\n\telse\n\t\terr = -ENOENT;\n\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f", "hash": 18220699088629601462246906502957374129, "size": 71, "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
{"func": "static void dump_one_vdso_page(struct page *pg, struct page *upg)\n{\n\tprintk(\"kpg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(pg) << PAGE_SHIFT),\n\t       page_count(pg),\n\t       pg->flags);\n\tif (upg/* && pg != upg*/) {\n\t\tprintk(\" upg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(upg)\n\t\t\t\t\t\t       << PAGE_SHIFT),\n\t\t       page_count(upg),\n\t\t       upg->flags);\n\t}\n\tprintk(\"\\n\");\n}", "target": 1, "cwe": ["CWE-20"], "project": "linux-2.6", "commit_id": "89f5b7da2a6bad2e84670422ab8192382a5aeb9f", "hash": 198053340576165894602613243780199057717, "size": 13, "message": "Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>"}
